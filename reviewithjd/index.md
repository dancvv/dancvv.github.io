# 3.11 面试小总结


今天接到了一个面试电话，说明来意之后，我还以为应该安排到下周，还在想周几面。结果没想到要求立马面试，当场打了我一个措手不及。现在来复盘一下面试官给我提出的问题，问题都挺简单的，但是架不住我菜啊。Q为question，A为answer。

Q：Java为什么要少用String的连接操作，尽量少用String类型
> A：使用+连接字符串每次都生成新的对象，而且是在堆内存上进行，而堆内存速度比较慢(相对而言)，那么再大量连接字符串时直接+是不可取的，当然需要一种效率高的方法。Java提供的StringBuffer和StringBuilder就是解决这个问题的。区别是前者是线程安全的而后者是非线程安全的。此外，值得注意的一点是，驻留池是不会被GC回收的，它会在程序运行期间一直保留。
> String对象具有只读性，对他的任何引用都不能改变他的值。

Q：Java中的线程安全是什么
> A：线程安全就是线程同步的意思，当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问

Q：Java堆、栈分别是什么
> A：Java把内存划分成两种，一种是栈内存，一种是堆内存。至于“方法区”（静态存储区），可以理解为：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。总的来说：堆和栈针对非静态数据，而方法区针对静态数据。
> **栈**：
> 简单理解：堆栈（stack）是操作系统在建立某个进程或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有先进后出的特性。
> 特点：存取速度比堆要快，仅次于直接位于CPU中的寄存器。栈中的数据可以共享（意思是：栈中的数据可以被多个变量共同引用）。
> 缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
> 相关存放对象：
> ①一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄【例如：在函数中定义的一些基本类型的变量和对象的引用变量】。
> ②方法的形参 直接在栈空间分配，当方法调用完成后从栈空间回收。
> 特殊：
> ①方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。
> ②局部变量new出来之后，在栈控件和堆空间中分配空间，当局部变量生命周期结束后，它的栈空间立刻被回收，它的堆空间等待GC回收。
> **堆**：
> 简单理解：
> 每个Java应用都唯一对应一个JVM实例，每一个JVM实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或者数组都放在这个堆中，并由应用所有的线程共享。Java中分配堆内存是自动初始化的，Java中所有对象的存储控件都是在堆中分配的，但这些对象的引用则是在栈中分配，也就是一般在建立一个对象时，堆和栈都会分配内存。
> 特点：
> 可以动态地分配内存大小、比较灵活，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。
> 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
> 主要存放：
> ①由new创建的对象和数组 ；
> ②this特殊：引用数据类型（需要用new来创建），既在栈控件分配一个地址空间，又在堆空间分配对象的类变量。

JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。

差异  
1.堆内存用来存放由new创建的对象和数组。
2.栈内存用来存放方法或者局部变量等
3.堆是先进先出，后进后出
4.栈是后进先出，先进后出

相同  
1.都是属于Java内存的一种
2.系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它

**引申：**
JVM的分区可分为三个：堆（heap）、栈（stack）和方法区（method）  
**堆区：**
存储的全是对象，每个对象都包含一个与之对应的class信息（我们常说的类类型，`Clazz.getClass()`等方式获取），class目的是得到操作指令。

JVM只有一个堆区（heap）被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。【这里的‘对象’，就不包括基本数据类型】
**栈区：**
每个线程包含自己的一个栈区，栈中只保存基本数据类型的对象和自定义对象的引用。
每个栈中的数据（基本类型和对象引用）都是私有的，其他栈不可访问。

栈 = 基本类型变量区 + 执行环境上下文 + 操作指令区（存放操作指令）
方法区

又称为‘静态区’，和堆一样，被所有的线程共享。

方法区包含所有的class和static变量。


Q：Java垃圾回收机制(GC)
> 垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。
> 垃圾回收主要有四种算法，分别是标记-清除、标记-复制、标记-整理和分代收集。
> **标记-收集**
> 顾名思义，标记-清除算法分为两个阶段，标记(mark)和清除(sweep)。
> 标记：遍历所有的GC Roots，然后将所有的GC Roots可达的对象标记为存活的对象。
> 清除：清除的过程将遍历所有堆中的对象，将没有标记的对象全部清除。
> 这个算法是遍历所有内存，进行标记清理后会出现内存地址不连续，出现垃圾碎片
> **标记-复制**
> 复制算法将内存分为两个区间,这两个区间是动态的，在任意一个时间点，所有分配的对象内存只能在其中一个区间（活动区间），另外一个区间就是空闲区间。
> 当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。GC线程会将活动空间内的，全部复制到空闲区间，且严格按照内存地址一次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。
> 缺点是空出一半的空间。
> **标记-整理**
> 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
> 优点明显，解决清除算法内存分散，弥补复制算法内存减半；缺点也很明显，多了一部分整理工作。
> **分代收集**
> 一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
> 比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

Q：HotSpot为什么要分为新生代和老年代？
> 因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。

这一次的面试以我毫无准备的状态结束，我自己都知道面试结果极差，基本问一个不会一个，面试官估计都无语了，就这还研究生。

上面的答案均整理自互联网，如有侵权，请联系我删除。
