# 3.11 面试小总结


今天接到了一个面试电话，说明来意之后，我还以为应该安排到下周，还在想周几面。结果没想到要求立马面试，当场打了我一个措手不及。现在来复盘一下面试官给我提出的问题，问题都挺简单的，但是架不住我菜啊。Q为question，A为answer。

Q：Java为什么要少用String的连接操作，尽量少用String类型
> A：使用+连接字符串每次都生成新的对象，而且是在堆内存上进行，而堆内存速度比较慢(相对而言)，那么再大量连接字符串时直接+是不可取的，当然需要一种效率高的方法。Java提供的StringBuffer和StringBuilder就是解决这个问题的。区别是前者是线程安全的而后者是非线程安全的。此外，值得注意的一点是，驻留池是不会被GC回收的，它会在程序运行期间一直保留。
> String对象具有只读性，对他的任何引用都不能改变他的值。

Q：Java中的线程安全是什么
> A：线程安全就是线程同步的意思，当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问

Q：Java堆、栈分别是什么
> A：Java把内存划分成两种，一种是栈内存，一种是堆内存。至于“方法区”（静态存储区），可以理解为：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。总的来说：堆和栈针对非静态数据，而方法区针对静态数据。
> **栈**：
> 简单理解：堆栈（stack）是操作系统在建立某个进程或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有先进后出的特性。
> 特点：存取速度比堆要快，仅次于直接位于CPU中的寄存器。栈中的数据可以共享（意思是：栈中的数据可以被多个变量共同引用）。
> 缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
> 相关存放对象：
> ①一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄【例如：在函数中定义的一些基本类型的变量和对象的引用变量】。
> ②方法的形参 直接在栈空间分配，当方法调用完成后从栈空间回收。
> 特殊：
> ①方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。
> ②局部变量new出来之后，在栈控件和堆空间中分配空间，当局部变量生命周期结束后，它的栈空间立刻被回收，它的堆空间等待GC回收。
> **堆**：
> 简单理解：
> 每个Java应用都唯一对应一个JVM实例，每一个JVM实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或者数组都放在这个堆中，并由应用所有的线程共享。Java中分配堆内存是自动初始化的，Java中所有对象的存储控件都是在堆中分配的，但这些对象的引用则是在栈中分配，也就是一般在建立一个对象时，堆和栈都会分配内存。
> 特点：
> 可以动态地分配内存大小、比较灵活，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。
> 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
> 主要存放：
> ①由new创建的对象和数组 ；
> ②this特殊：引用数据类型（需要用new来创建），既在栈控件分配一个地址空间，又在堆空间分配对象的类变量。

JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。

差异  
1.堆内存用来存放由new创建的对象和数组。
2.栈内存用来存放方法或者局部变量等
3.堆是先进先出，后进后出
4.栈是后进先出，先进后出

相同  
1.都是属于Java内存的一种
2.系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它

**引申：**
JVM的分区可分为三个：堆（heap）、栈（stack）和方法区（method）  
**堆区：**
存储的全是对象，每个对象都包含一个与之对应的class信息（我们常说的类类型，`Clazz.getClass()`等方式获取），class目的是得到操作指令。

JVM只有一个堆区（heap）被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。【这里的‘对象’，就不包括基本数据类型】
**栈区：**
每个线程包含自己的一个栈区，栈中只保存基本数据类型的对象和自定义对象的引用。
每个栈中的数据（基本类型和对象引用）都是私有的，其他栈不可访问。

栈 = 基本类型变量区 + 执行环境上下文 + 操作指令区（存放操作指令）
方法区

又称为‘静态区’，和堆一样，被所有的线程共享。

方法区包含所有的class和static变量。


Q：Java垃圾回收机制(GC)


Q：HotSpot为什么要分为新生代和老年代？
> 因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。
