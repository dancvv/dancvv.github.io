[{"categories":null,"content":"SpringBoot生成OpenAPI 3.0文档 ","date":"2022-02-14","objectID":"/springdoc/:0:0","tags":null,"title":"Springdoc","uri":"/springdoc/"},{"categories":null,"content":"概述 开发过程中需要写大量的接口文档，如果手写的话需要花费一定的时间，并且还需要额外的时间进行维护，为了避免这样的情况，开发人员可以引入文档管理工具进行自动生成。 目前，可以生成RESTful风格文档最为成熟，规范且完整的框架是Swagger。国内局大部分人还在用过时的Swagger2，已于17年停止维护并更名为Swagger3。 但是，本文并不会使用Swagger，而是使用与之类似的springdoc-openapi，这也是一个基于OpneAPI 3的Java库，帮助Spring boot工程自动生成API文档。在运行时检查应用程序，来推断基于spring配置，类结构和各种注释的API语义，同时，还支持Swagger-ui界面。 ","date":"2022-02-14","objectID":"/springdoc/:1:0","tags":null,"title":"Springdoc","uri":"/springdoc/"},{"categories":null,"content":"pom引入 整合spring-boot和swagger-ui，添加以下的依赖即可完成，不需要其他的设置 \u003cdependency\u003e \u003cgroupId\u003eorg.springdoc\u003c/groupId\u003e \u003cartifactId\u003espringdoc-openapi-ui\u003c/artifactId\u003e \u003cversion\u003e1.6.6\u003c/version\u003e \u003c/dependency\u003e 这个依赖会自动部署swagger-ui到spring-boot应用： 文档以HTML的形式展现 文档也可以yaml格式展现，路径如下：/v3/api-docs.yaml ","date":"2022-02-14","objectID":"/springdoc/:2:0","tags":null,"title":"Springdoc","uri":"/springdoc/"},{"categories":null,"content":"文档设置 swagger-ui路径 自定义访问路径 springdoc.swagger-ui.path=/swagger-ui.html swagger-ui开启 是否开启功能 springdoc.api-docs.enabled=true 简单的配置之后，启动项目，在本地端口加上自定义的路径就可以进入API接口文档。以默认项目8080端口为例，其访问路径为htttp://localhost:8080/swagger-ui.html ","date":"2022-02-14","objectID":"/springdoc/:3:0","tags":null,"title":"Springdoc","uri":"/springdoc/"},{"categories":null,"content":"Docker learning script Docker 目前存在多个国内镜像，以阿里云网易云为主，可以选定永久的和临时的。加速服务需要去对应的网站选择，随后按照步骤配置进入本机 配置文档位于/etc/sysconfig/docker,，重启检查是否生效service docker restart. 运行hello world sample ","date":"2021-12-05","objectID":"/docker/:0:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"基础命令 docker build docker pulldocker run ","date":"2021-12-05","objectID":"/docker/:1:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"docker为什么快 容器，是一个运行时环境，也就是集装箱。比VM快的原因： 有更少抽象层，不需要HyperVisor实现硬件资源虚拟化，因此运行效率更高 利用宿主机的内核，而不需要Guest OS。当新建一个虚拟机时， 虚拟机需要重新加载一个操作系统内核。而docker直接利用宿主机内核，因此加载速度极快。 ","date":"2021-12-05","objectID":"/docker/:2:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"docker 常用命令 ","date":"2021-12-05","objectID":"/docker/:3:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"镜像命令 鲸鱼背上有大海 蓝色的大海中 »»\u003e 宿主机系统 鲸鱼 »»\u003e docker 集装箱 »»\u003e 容器实例 from 来自我们能的镜像模板 docker images 列出本地主机的镜像 可以使用唯一ID和仓库名来管理 -a 列出本地所有的镜像（含中间镜像层）-q 只显示当前镜像的id--digests 描述消息--no-trunc 显示完整信息 docker search 搜索某个镜像名字 搜索网站为docker hub docker pull 从官方抓取镜像 没写版本号，代表直接抓取最新版本 docker pull tomact 等价 docker pull tomcat:latest -docker rmi 移除镜像，remove images -f 强制删除 docker rmi -f 镜像ID docker rmi -f 镜像名1：tag 镜像名2：tag 删除全部docker rmi -f $(docker images -qa) 子命令解释，查询出docker所有镜像id，并删除 ","date":"2021-12-05","objectID":"/docker/:3:1","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"容器命令 可以把容器看为一个简易版的Linux系统。有镜像才能创建容器，这是一个根本性的前提 新建并启动容器 docker run [options] image [command] –name 重命名,将容器名 docker run -it --name mycentos centos 将centos重命名为mycentos -i 以交互模式运行容器，通常与-t同时使用 -t 为容器重新分配一个伪输入终端，通常-i同时使用 查看容器 docker ps查看当前所有进程 -a 列出所有正在运行的容器+历史上运行过的 -l 最后一次运行的 -n 显示最近n个创建的容器 -q 静默模式，只显示容器编号 以上命令都可以组合使用 容器重命名 docker rename oldName newName 对部分容器重新命名 启动容器 docker start 容器ID或者容器名 退出容器 exit容器停止退出 ctrl + p + q容器不停止退出 重启容器 docker restart ID 关闭容器 kill 直接删除掉该进程 stop 温柔一些的停止 删除容器 docker rm 容器ID -f 强制删除 一次性删除多个镜像 docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm 运行容器 该命令启动守护式容器 docker run -d centos 使用centos：latest，以后台模式启动一个容器 前台启动，交互形式-it 日志打印 docker logs 查看容器内的运行进程 docker top 用户id 查看容器内部细节 docker inspect 容器id 重新进入容器内环境 退出后进入容器，exec和attach的区别 attach 进入已经启动的容器终端，不会启动新的进程 docker attach 容器id exec 是在容器中打开新的终端，并且可以启动新的进程 docker exec -t 容器id ls -l /tmp 容器内拷贝文件到本机 docker cp 容器ID 基本路径 从主机复制到容器sudo docker cp host_path containerID:container_path 从容器复制到主机sudo docker cp containerID:container_path host_path ","date":"2021-12-05","objectID":"/docker/:3:2","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"Docker镜像 UnionFS 联合文件系统，是一种分层、轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加。 好处 共享资源，如果有多个镜像都从base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像。 特点 镜像都是只读的，这一层通常称作容器层，容器层之下的称作镜像层 commit命令 docker commit 提交容器副本使之成为一个新的镜像 docker commit -m =\"提交的描述信息\" -a=\"作者\" 容器ID要创建的目标镜像名:[标签名] docker commit -m =\"description\" -a=\"author\" newName:1.2 docker run -it -p 8080:8080 tomcat -p 本地端口:docker端口 -P 随机分配端口 ","date":"2021-12-05","objectID":"/docker/:4:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"容器数据卷 为了放置删除镜像后数据丢失，保存数据，使用卷，完全独立于容器之外的 完全容器的持久化，容器间继承+共享数据 ","date":"2021-12-05","objectID":"/docker/:4:1","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"数据卷 容器内添加：直接命令添加，DockerFile添加 直接命令添加 docker run -it -v /宿主机绝对路径目录：/容器目录 镜像名 OS X系统链接必须采用绝对路径，以及将/var添加进docker设置中的resources\u003efile sharing docker run -it -v /Users/weivang/dataVolume:/datalum centos 带权限的命令 docker run -it -v /宿主机绝对路径目录：/容器目录:ro 镜像名 该命令进入之后，不可进行写操作，仅可读操作 验证映射链接成功 docker inspect 容器id ","date":"2021-12-05","objectID":"/docker/:4:2","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"DockerFile添加 根目录下新建一个DockerFile文件，使用Volume指令添加 使用DockerFile是出于可移植和分享的考虑;由于宿主机目录是依赖于特定宿主机的，并不能保证所有的宿主机都存在这样的特定目录。 DockerFile文件 # DockerFile构建 FROM centos VOLUME [\"/dataVolume1\",\"/dataVolume2\"] CMD echo \"finished，-----successed\" CMD echo \"finished，-----successed\" 文件构建命令docker build -f 使用dockerfile构建的容器自动挂载的数据卷，docker会在宿主机目录自动生成对应的文件 ","date":"2021-12-05","objectID":"/docker/:4:3","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"数据卷容器 其他容器可以通过已经挂载在父容器上的数据卷实现数据共享，挂载数据卷的容器，称之为数据卷容器。 实现数据共享，一条绳上的蚂蚱。 -volumes-from复制容器数据卷 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止 ","date":"2021-12-05","objectID":"/docker/:4:4","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"DockerFile解析 Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 基础知识 每条保留字指令都必须为大写字母，且后面要跟随至少一个参数 从上到下，顺序执行 大致流程 从基础镜像运行一个容器 执行一条指令对容器进行修改。 从应用软件的角度来看，DockerFile、Docker镜像与Docker容器分别代表软件的三个不同阶段。 DockerFile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件的运行态 DockerFile体系结构，保留字指令 FROM 基础镜像 MAINTAINER 维护者 RUN 执行的命令 EXPOSE 暴露接口 WORKDIR 工作目录，终端默认登录之后的工作目录 ENV 用来在构建镜像过程中设置环境变量 ADD 拷贝+解压缩 COPY 复制 VOLUME 容器数据卷 CMD 容器启动时要运行的命令 ENTRYPOINT 指定一个容器时要运行的命令,ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数 ONBUILD 父镜像在子镜像被继承后，父镜像的onbuild被触发 案例 自定义一个centos镜像，使得镜像mycentos自己的镜像具备如下： 登录后的默认路径 vim编辑器 查看网络配置ifconfig支持 FROM CENTOS ENV mypath /tmp WORKDIR $mypath RUN yum -y install vim RUN yun -y install net-tools EXPOSE 80 CMD echo $mypath CMD echo \"success ----- ok\" CMD /bin/bash 构建，docker build -t 新镜像名字:tag .，注：最后的 . 代表本次执行的上下文路径，下一节会介绍。 运行，docker run -it 新镜像名字:tag 列出镜像的变更历史，docker history 镜像名 CMD和entrypoint的区别 ","date":"2021-12-05","objectID":"/docker/:5:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"安装mysql及使用 docker search mysql docker pull mysql:5.6 docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 停止mysql之后，使用restart命令重新进入 docker restart 容器id ","date":"2021-12-05","objectID":"/docker/:6:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"创建conda环境，激活其他虚拟环境时报错 今天本来正常从github找到一个项目，打算按照常规操作跑起来看看结果，结果一下子出现一堆报错，一下子慌了神，bing（必应）了半天总算找到症结所在。 ","date":"2021-12-05","objectID":"/condafix/:0:0","tags":null,"title":"conda报错：An unexpected error has occurred. Conda has prepared the above report. Upload did not complete.","uri":"/condafix/"},{"categories":null,"content":"问题复现 创建环境、切换环境时，出现以下报错信息： C:\\Users\\windows\u003econda create -n na python=3.6 Collecting package metadata (current_repodata.json): failed # \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e ERROR REPORT \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c Traceback (most recent call last): File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\exceptions.py\", line 1079, in __call__ return func(*args, **kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\main.py\", line 84, in _main exit_code = do_call(args, p) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\conda_argparse.py\", line 83, in do_call return getattr(module, func_name)(args, parser) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\main_create.py\", line 41, in execute install(args, parser, 'create') File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\install.py\", line 261, in install unlink_link_transaction = solver.solve_for_transaction( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 114, in solve_for_transaction unlink_precs, link_precs = self.solve_for_diff(update_modifier, deps_modifier, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 157, in solve_for_diff final_precs = self.solve_final_state(update_modifier, deps_modifier, prune, ignore_pinned, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 262, in solve_final_state ssc = self._collect_all_metadata(ssc) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\common\\io.py\", line 88, in decorated return f(*args, **kwds) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 425, in _collect_all_metadata index, r = self._prepare(prepared_specs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 1020, in _prepare reduced_index = get_reduced_index(self.prefix, self.channels, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\index.py\", line 288, in get_reduced_index new_records = SubdirData.query_all(spec, channels=channels, subdirs=subdirs, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 140, in query_all result = tuple(concat(executor.map(subdir_query, channel_urls))) File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\", line 611, in result_iterator yield fs.pop().result() File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\", line 439, in result return self.__get_result() File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\", line 388, in __get_result raise self._exception File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\thread.py\", line 57, in run result = self.fn(*self.args, **self.kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 132, in \u003clambda\u003e subdir_query = lambda url: tuple(SubdirData(Channel(url), repodata_fn=repodata_fn).query( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 145, in query self.load() File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 209, in load _internal_state = self._load() File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 371, in _load raw_repodata_str = fetch_repodata_remote_request( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 694, in fetch_repodata_remote_request resp = session.get(join_url(url, filename), headers=headers, proxies=session.proxies, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\", line 555, in get return self.request('GET', url, **kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\", line 542, in request resp = self.send(prep, **send_kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\", line 655, in send r = adapter.send(request, **kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\adapters.py\", line 439, in send resp = conn.urlopen( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\connectionpool.py\", line 696, ","date":"2021-12-05","objectID":"/condafix/:1:0","tags":null,"title":"conda报错：An unexpected error has occurred. Conda has prepared the above report. Upload did not complete.","uri":"/condafix/"},{"categories":null,"content":"解决方案 出现这个问题后，有比较多的解决方案： 使用命令清理缓存，conda clean -i 删除 ~/.condarc (C:\\Users\\admin) 关闭梯子（大杀招） 反正就是让人头大，解决方案希望对大家有用 ","date":"2021-12-05","objectID":"/condafix/:2:0","tags":null,"title":"conda报错：An unexpected error has occurred. Conda has prepared the above report. Upload did not complete.","uri":"/condafix/"},{"categories":null,"content":"Linux常用命令 一些感想 ","date":"2021-12-04","objectID":"/reading/:0:0","tags":null,"title":"Reading","uri":"/reading/"},{"categories":null,"content":"测试 ","date":"2021-12-04","objectID":"/reading/:1:0","tags":null,"title":"Reading","uri":"/reading/"},{"categories":null,"content":"第一次部署网站\u0026一些想法 ","date":"2021-11-21","objectID":"/first/:0:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"一些废话 虽然这个标题叫“第一次部署网站”，但其实我私下里已经部署过另外一个博客了，所以实际上是第二次。之前部署的博客是基于halo这个动态博客框架，为什么会放弃这个已经部署好的网站，而选择另外的框架呢？ 主要原因是我比较折腾，halo提供的博客系统其实非常完善了，提供了完善的前后台管理，评论系统，搜索等功能，本来我也非常喜欢的。 但是有一个缺点我不太能接受，它需要登录到博客系统后台才能开始写文章，当然你也可以在本地创作完稿子，再把它复制粘贴到后台，然后发布。这个操作也不是不行，对于喜欢本地Markdown创作，然后push到博客上的同学来说，感觉比较别扭。 其实，最为主要的原因是动态博客需要服务器来进行部署，服务器虽然不是太贵，以腾讯云的轻量云服务器来说，第一次购买一年74元，再搭上一个域名，小两百就没了，所以能白嫖就白嫖。 静态博客系统相比于动态博客的优点在于网站部署可以完全不用服务器，也就是说可以省掉74块钱乃至更多，毕竟服务器续费需要花更多钱。 ","date":"2021-11-21","objectID":"/first/:1:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"正文 部署一个不花钱的博客，有比较多的选项，常用的Github Pages + Hugo/Hexo 等其他静态博客系统，如果觉得Github访问过慢，可以采用国内的Gitee Pages，又或者使用其他云服务商提供的CDN加速。 个人推荐使用Hugo来构建自己的博客，倒也没啥太大的原因，就是因为我的电脑不能安装Hexo，就弃坑了（O(∩_∩)O哈哈~）。Hugo也很强大，Github 关注55.6k，而Hexo只有33.8k，用就用最热门的，出bug了也方便找。下面是部署使用的一些环境： 操作系统采用 Ubuntu 20.04 LTS，博客系统采用Hugo，静态托管使用Github Pages。 ","date":"2021-11-21","objectID":"/first/:2:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"Hugo安装和配置 Hugo的安装比较简单，Windows平台需要进入Hugo官网下载Hugo，Ubuntu只需要在终端输入以下命令： sudo apt-get install hugo 不确定是否安装完成，可以验证一下： hugo version 确认安装完成之后，找到一个喜欢的目录 hugo new site myfirstblog 运行以上的命令会生成一个myfirstblog文件夹，请熟记这个目录，他就是以后的大本营，可千万别给删了，这个文件夹里包含了博客系统的所有文件。 创建完一个博客项目后，去官网选一个喜欢的主题 cd myfirstblog git clone https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 在这里，我选择了一个比较经典的主题–PaperMod，使用git clone的方式下载themes文件夹中。每一个主题都有自己特有的配置，为了让这些配置生效，需要将它们写入到配置文档中。 Hugo提供了一个文档config.toml来编写自己的主题设置，该文件位于主目录下，以PaperMod主题为例，官方会提供一个完整的配置示例，在初期我们只要将这个配置复制粘贴就可以用了，后期上手之后可以做更多定制化的内容，配置如下： baseURL: \"https://examplesite.com/\" title: ExampleSite paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: ExampleSite description: \"ExampleSite description\" keywords: [Blog, Portfolio, PaperMod] author: Me # author: [\"Me\", \"You\"] # multiple authors images: [\"\u003clink or path of image for opengraph, twitter-cards\u003e\"] DateFormat: \"January 2, 2006\" defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \"\u003clink / abs url\u003e\" favicon16x16: \"\u003clink / abs url\u003e\" favicon32x32: \"\u003clink / abs url\u003e\" apple_touch_icon: \"\u003clink / abs url\u003e\" safari_pinned_tab: \"\u003clink / abs url\u003e\" label: text: \"Home\" icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \"This is subtitle\" imageUrl: \"\u003cimg location\u003e\" imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \"Hi there \\U0001F44B\" Content: Welcome to my blog socialIcons: - name: twitter url: \"https://twitter.com/\" - name: stackoverflow url: \"https://stackoverflow.com\" - name: github url: \"https://github.com/\" analytics: google: SiteVerificationTag: \"XYZabc\" bing: SiteVerificationTag: \"XYZabc\" yandex: SiteVerificationTag: \"XYZabc\" cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \"https://github.com/\u003cpath_to_repo\u003e/content\" Text: \"Suggest Changes\" # edit text appendFilePath: true # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\"title\", \"permalink\", \"summary\", \"content\"] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 # Read: https://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma # pygmentsUseClasses: true # markup: # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai 上面的操作完成了骨干的构建，下面开始完善博客的血肉，即文章内容，创建一篇新的文章采用以下命令： hugo new post/first.md 当前上面的操作准备就绪后，可以使用Hugo的功能进行本地预览 hugo server 开启服务后，在浏览器输入http://localhost:1313即可进入网站，在网站中可以看见刚下载好的主题和创建的第一篇文章。至此，Hugo的初步搭建就完成了，使用下面的命令可以完成Hugo的生产环境搭建： hugo -D ","date":"2021-11-21","objectID":"/first/:3:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"Github Pages配置 完成上面的工作之后，就可以进行下面的工作，将自己的静态博客部署到Github Pages上，实现全网访问(理论上，受限于国内的网络)。 进入Github官网，点击右上方的\"+”，新建一个仓库，仓库名为\"xxx.github.io”，第一个xxx必须为用户的昵称，没有商量的余地。比如我的Github用户名为\"dancingmonkey”，那么仓库名就为\"dancingmonkey.github.io”，这个极容易出错，不按照命名规则来，可能就要花很长时间来debug了。 仓库创建好之后，将博客目录下的public文件夹中的所有内容上传到该仓库： cd public git init git commit -m \"first commit\" git remote add origin 仓库名 git push -u origin master 如果按照步骤来的话，每个配置都保持一致，那么这个时候你的博客就可以在全网访问了。追求更好的用户体验可以购买一个域名，在域名提供商的DNS解析处，将域名解析到对应的Github仓库名。同时，还需要在仓库的设置页面中，找到Pages设置项，在其中的Custom Domain(自定义域名)处输入自己购买的域名。 至此，使用Hugo和Github Pages搭建一个免费的静态博客就完成了，唯一需要额外花费的就是域名了。 ","date":"2021-11-21","objectID":"/first/:4:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"一些感想 花了很长的时间才把网站部署起来，一方面是懒，云服务器买了，域名也买了，啥都齐了，但就是没把博客搞起来。现在回想起来，实际用来部署网站时间的，也就1个小时，剩下的时间都在找bug了。总是不相信别人的教程，每次都偏离一点路线，然后就出大错了。总结下来，一定要按步骤来，在复现结果之后在开始玩其他花样，还没有复现就开始玩花样等于找死。 ","date":"2021-11-21","objectID":"/first/:5:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"}]