[{"categories":null,"content":"今天接到了一个面试电话，说明来意之后，我还以为应该安排到下周，还在想周几面。结果没想到要求立马面试，当场打了我一个措手不及。现在来复盘一下面试官给我提出的问题，问题都挺简单的，但是架不住我菜啊。Q为question，A为answer。 Q：Java为什么要少用String的连接操作，尽量少用String类型 A：使用+连接字符串每次都生成新的对象，而且是在堆内存上进行，而堆内存速度比较慢(相对而言)，那么再大量连接字符串时直接+是不可取的，当然需要一种效率高的方法。Java提供的StringBuffer和StringBuilder就是解决这个问题的。区别是前者是线程安全的而后者是非线程安全的。此外，值得注意的一点是，驻留池是不会被GC回收的，它会在程序运行期间一直保留。 String对象具有只读性，对他的任何引用都不能改变他的值。 Q：Java中的线程安全是什么 A：线程安全就是线程同步的意思，当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问 Q：Java堆、栈分别是什么 A：Java把内存划分成两种，一种是栈内存，一种是堆内存。至于“方法区”（静态存储区），可以理解为：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。总的来说：堆和栈针对非静态数据，而方法区针对静态数据。 栈： 简单理解：堆栈（stack）是操作系统在建立某个进程或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有先进后出的特性。 特点：存取速度比堆要快，仅次于直接位于CPU中的寄存器。栈中的数据可以共享（意思是：栈中的数据可以被多个变量共同引用）。 缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 相关存放对象： ①一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄【例如：在函数中定义的一些基本类型的变量和对象的引用变量】。 ②方法的形参 直接在栈空间分配，当方法调用完成后从栈空间回收。 特殊： ①方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。 ②局部变量new出来之后，在栈控件和堆空间中分配空间，当局部变量生命周期结束后，它的栈空间立刻被回收，它的堆空间等待GC回收。 堆： 简单理解： 每个Java应用都唯一对应一个JVM实例，每一个JVM实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或者数组都放在这个堆中，并由应用所有的线程共享。Java中分配堆内存是自动初始化的，Java中所有对象的存储控件都是在堆中分配的，但这些对象的引用则是在栈中分配，也就是一般在建立一个对象时，堆和栈都会分配内存。 特点： 可以动态地分配内存大小、比较灵活，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 主要存放： ①由new创建的对象和数组 ； ②this特殊：引用数据类型（需要用new来创建），既在栈控件分配一个地址空间，又在堆空间分配对象的类变量。 JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 差异 1.堆内存用来存放由new创建的对象和数组。 2.栈内存用来存放方法或者局部变量等 3.堆是先进先出，后进后出 4.栈是后进先出，先进后出 相同 1.都是属于Java内存的一种 2.系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它 引申： JVM的分区可分为三个：堆（heap）、栈（stack）和方法区（method） 堆区： 存储的全是对象，每个对象都包含一个与之对应的class信息（我们常说的类类型，Clazz.getClass()等方式获取），class目的是得到操作指令。 JVM只有一个堆区（heap）被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。【这里的‘对象’，就不包括基本数据类型】 栈区： 每个线程包含自己的一个栈区，栈中只保存基本数据类型的对象和自定义对象的引用。 每个栈中的数据（基本类型和对象引用）都是私有的，其他栈不可访问。 栈 = 基本类型变量区 + 执行环境上下文 + 操作指令区（存放操作指令） 方法区 又称为‘静态区’，和堆一样，被所有的线程共享。 方法区包含所有的class和static变量。 Q：Java垃圾回收机制(GC) Q：HotSpot为什么要分为新生代和老年代？ 因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。 ","date":"2022-03-11","objectID":"/reviewithjd/:0:0","tags":null,"title":"3.11 面试小总结","uri":"/reviewithjd/"},{"categories":null,"content":"写在前面 在接触到Docker之后，发现他火起来不是没有道理的，极大的简化了安装过程，特别是本机还有一些老旧项目的数据库，但是又不能直接删掉弄新的。最近学习一个项目，需要安装各种数据，像MySQL，MongoDB之类的安装，只需要几个命令就能轻松搞起来。下面我会分章来讲解怎么利用Docker安装MySQL，MongoDB和Redis数据库。 ","date":"2022-03-10","objectID":"/docker-utils/:1:0","tags":null,"title":"Docker安装常用的数据库","uri":"/docker-utils/"},{"categories":null,"content":"MySQL安装 ","date":"2022-03-10","objectID":"/docker-utils/:2:0","tags":null,"title":"Docker安装常用的数据库","uri":"/docker-utils/"},{"categories":null,"content":"MongoDB安装 ","date":"2022-03-10","objectID":"/docker-utils/:3:0","tags":null,"title":"Docker安装常用的数据库","uri":"/docker-utils/"},{"categories":null,"content":"Redis安装 ","date":"2022-03-10","objectID":"/docker-utils/:4:0","tags":null,"title":"Docker安装常用的数据库","uri":"/docker-utils/"},{"categories":null,"content":"LeetCode 1356，题目链接 代码如下： class Solution { public int[] sortByBits(int[] arr) { // 巧妙的解法 // 利用java自身携带的统计函数 for(int i=0; i\u003carr.length; i++){ arr[i] = Integer.bitCount(arr[i]) * 1000000 + arr[i]; } Arrays.sort(arr); // 排序完之后对数组进行取余操作，得到原来的数组 for(int i=0; i\u003carr.length; i++){ arr[i] = arr[i] % 1000000; } return arr; } } ","date":"2022-03-06","objectID":"/leetcode-1356/:0:0","tags":null,"title":"[Leetcode 1356] 统计数字在二进制下1的数目排序","uri":"/leetcode-1356/"},{"categories":null,"content":"面试题 02.07 链表相交，题目链接点我 这个题我先用了最耗时的方法做，既然是让最第一个相交的节点，也就是说，找到第一个相等的点。既然是相等，那么我把一个链表的所有节点存到一个哈希表中，让后让第二个链表在遍历的同时，不停确认哈希表中是不是有这个节点，如果有，终止循环，找到节点，没有就返回null。 代码如下： public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode cross = null; ListNode loopA = headA; ListNode loopB = headB; if(headA ==null || headB ==null) return cross; Map\u003cListNode,Integer\u003e hash = new HashMap\u003c\u003e(); while(loopA != null){ hash.put(loopA,loopA.val); loopA = loopA.next; } while(loopB != null){ if(hash.containsKey(loopB)){ cross = loopB; // 条件符合之后需要跳出循环 break; } loopB = loopB.next; } return cross; } } 也有十分巧妙的解法，两个链表如果相交，遍历完a后，紧接着遍历b，另一个链表b采取同样的操作，遍历完b，然后遍历a，他们会在相等的位置停下。因为a+b=b+a，其长度一致，转一圈终究会回到共同的点。如果两个链表没有相交的点，A的长度是a，B的长度是b，如果两者不相交，则两链的头结点在同时走了a+b步后均会指向null，即满足了循环的终止条件。 代码如下： public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode a = headA, b = headB; // A的长度是a，B的长度是b，如果两者不相交，则两链的头结点在同时走了a+b步后均会指向null，即满足了循环的终止条件。 while(a != b){ a = a != null ? a.next : headB; b = b != null ? b.next : headA; } return a; } } ","date":"2022-03-02","objectID":"/offer-07/:0:0","tags":null,"title":"面试题 02.07 链表相交","uri":"/offer-07/"},{"categories":null,"content":"LeetCode 537，题目链接点我 这个题一开始想到了暴力破解的方式，利用两层for循环，以第一层为起点，在第二层里面不断累加，如果和大于等于target，记录当前长度，并与之前的长度做对比，然后结束第二层循环。不断的进行此操作就可以拿到结果。 代码如下： class Solution { public int minSubArrayLen(int target, int[] nums) { // 暴力破解 int res = Integer.MAX_VALUE; for(int i=0; i\u003cnums.length; i++){ int sum = 0; for(int j=i; j\u003cnums.length; j++){ sum += nums[j]; if(sum \u003e= target){ int subLen = j-i+1; res = res \u003e subLen ? subLen : res; break; } } } // 此处判断结果是否变过 return res == Integer.MAX_VALUE ? 0 : res; } } ","date":"2022-02-28","objectID":"/leetcode-209/:0:0","tags":null,"title":"[LeetCode 209] 长度最小的子数组","uri":"/leetcode-209/"},{"categories":null,"content":"LeetCode 2106，题目链接点我 这个题虽然是个简单题，但是我还是花了一点时间来解答，猛的想错了方向，差点没绕出来。其实，还是很简单的，只需要采用一个for循环外加两个条件判断即可。 在循环内，我们首先要知道这个数组的最小值，那么简单的if判断就能找到最小值。现在的问题怎么找到第二个数，使得两者之间的差值最大。题目要求第二个数必须在第一个数后面，也就是说两个数的序号必须是一前一后，前面的数小于后面的数。 思路有了，代码如下： class Solution { public int maximumDifference(int[] nums) { int diff = -1; int min = nums[0]; for(int i=1;i\u003cnums.length;i++){ // 找到最小值 if(min \u003e nums[i]){ min = nums[i]; }else if(nums[i]\u003emin){ // 判断差值是否小于当前差值,同时，相减的两个数不能相等 diff = Math.max(diff, nums[i] - min); } } return diff; } } ","date":"2022-02-26","objectID":"/leetcode-2106/:0:0","tags":null,"title":"[LeetCode 2106] 增量元素之间的最大差值","uri":"/leetcode-2106/"},{"categories":null,"content":"LeetCode 1523，题目链接点我 一行代码解决 high加一是为了补上缺失的那一个，[0,x]范围的奇数必定为x的一半。如果x为奇数，比如7，根据Java的规则只能拿到3，实际有4个，就是把7给漏了，所以要加1. 代码如下： class Solution { public int countOdds(int low, int high) { return (high+1)/2 - low/2; } } ","date":"2022-02-25","objectID":"/leetcode-1523/:0:0","tags":null,"title":"[LeetCode 1523] 在区间范围内统计奇数数目","uri":"/leetcode-1523/"},{"categories":null,"content":"LeetCode 537，题目链接点我 这个题涉及到数学中复变函数的运算，也很简单，没有涉及到复杂运算，仅实现复数乘法。它的难处在于如何让两个字符串实现乘法运算。 简单科普一下复数乘法，两个复数的和依然是复数，它的实部是原来两个复数实部的和，它的虚部是原来两个虚部的和。复数的加法满足交换律和结合律。 根据复数乘法的规则，我们首先需要取到实部和虚部，这个可利用String类的split()方法，把一个代表复数的字符串分解为实部和虚部的字符数组。得到转换后的字符数组，我们将每个字符转换为整数，根据复数规则，进行分解运算。 分解运算具体步骤： $(a+bi)(c+di)=(ac-bd)+(ad+b*c)i$ 把分解运算的结果按照指定的字符串形式返回，代码如下： class Solution { public String complexNumberMultiply(String num1, String num2) { String[] ss1 = num1.split(\"\\\\+|i\"), ss2 = num2.split(\"\\\\+|i\"); int a = parse(ss1[0]), b = parse(ss1[1]); int c = parse(ss2[0]), d = parse(ss2[1]); int A = a * c - b * d, B = b * c + a * d; return A + \"+\" + B + \"i\"; } int parse(String s) { return Integer.parseInt(s); } } ","date":"2022-02-25","objectID":"/leetcode-537/:0:0","tags":null,"title":"[LeetCode 537] 复数乘法","uri":"/leetcode-537/"},{"categories":null,"content":"LeetCode 1706，题目链接点我 拿到这个题之后，首先分析其限制条件。根据题意可以发现，球会在三个地方卡住，左右两侧的墙壁上，以及两侧挡板形成的V型槽。 得到限制条件后，开始想怎么让程序找到路线，采用重力模拟的方法来实现。小球自上而下坠落，箱子已经按照二维数组的方式进行编码，那我们首先查第一列的小球，看它会不会成功走出小盒。也就是说采用两层for循环查找，第一层for循环用来演示每一列小球的位置，第二层for循环用来检验这一列小球会不会走出小盒。 在第二层for循环里，我们需要判断这个小球是否满足走出去的条件，即开始分析的三个地方。这里的难点在于不太好分析为什么不会再V型槽处卡住，小球卡住的V型槽都在同一层。那么只需要记录当前小球的移动位置，小球在下一层的坐标，把这个坐标带到当前层来，两个方向不一致就会在同一层形成V型槽，就卡住了。 代码如下： class Solution { public int[] findBall(int[][] grid) { int n = grid[0].length; int[] result = new int[n]; for(int i=0 ; i\u003cn ; i++){ int col = i; for(int[] nums:grid){ // 获取当前列的方向 int direction = nums[col]; // 移动后小球可能在的位置，左移一个，右移一个 col += direction; // 判断小球在不在界内，col为小球移动后的坐标 // 移动后的方向要求与上一个方向保持一致,一致就会形成V型槽 if(col\u003c0 || col==n || nums[col] != direction){ col = -1; break; } } // 记录结果 result[i] = col; } return result; } } ","date":"2022-02-24","objectID":"/leetcode-1706/:0:0","tags":null,"title":"[LeetCode 1706] 球会落何处","uri":"/leetcode-1706/"},{"categories":null,"content":"SpringBoot生成OpenAPI 3.0文档 ","date":"2022-02-14","objectID":"/springdoc/:0:0","tags":null,"title":"SpringBoot生成OpenAPI 3.0文档","uri":"/springdoc/"},{"categories":null,"content":"概述 开发过程中需要写大量的接口文档，如果手写的话需要花费一定的时间，并且还需要额外的时间进行维护，为了避免这样的情况，开发人员可以引入文档管理工具进行自动生成。 目前，可以生成RESTful风格文档最为成熟，规范且完整的框架是Swagger。国内局大部分人还在用过时的Swagger2，已于17年停止维护并更名为Swagger3。 但是，本文并不会使用Swagger，而是使用与之类似的springdoc-openapi，这也是一个基于OpneAPI 3的Java库，帮助Spring boot工程自动生成API文档。在运行时检查应用程序，来推断基于spring配置，类结构和各种注释的API语义，同时，还支持Swagger-ui界面。 ","date":"2022-02-14","objectID":"/springdoc/:1:0","tags":null,"title":"SpringBoot生成OpenAPI 3.0文档","uri":"/springdoc/"},{"categories":null,"content":"pom引入 整合spring-boot和swagger-ui，添加以下的依赖即可完成，不需要其他的设置 \u003cdependency\u003e \u003cgroupId\u003eorg.springdoc\u003c/groupId\u003e \u003cartifactId\u003espringdoc-openapi-ui\u003c/artifactId\u003e \u003cversion\u003e1.6.6\u003c/version\u003e \u003c/dependency\u003e 这个依赖会自动部署swagger-ui到spring-boot应用： 文档以HTML的形式展现 文档也可以yaml格式展现，路径如下：/v3/api-docs.yaml ","date":"2022-02-14","objectID":"/springdoc/:2:0","tags":null,"title":"SpringBoot生成OpenAPI 3.0文档","uri":"/springdoc/"},{"categories":null,"content":"文档设置 swagger-ui路径 自定义访问路径 springdoc.swagger-ui.path=/swagger-ui.html swagger-ui开启 是否开启功能 springdoc.api-docs.enabled=true 简单的配置之后，启动项目，在本地端口加上自定义的路径就可以进入API接口文档。以默认项目8080端口为例，其访问路径为htttp://localhost:8080/swagger-ui.html ","date":"2022-02-14","objectID":"/springdoc/:3:0","tags":null,"title":"SpringBoot生成OpenAPI 3.0文档","uri":"/springdoc/"},{"categories":null,"content":"注解迁移 从swagger2项目中迁移后，需要替换掉所有的swagger2注解： @Api → @Tag @ApiIgnore → @Parameter(hidden = true) or @Operation(hidden = true) or @Hidden @ApiImplicitParam → @Parameter @ApiImplicitParams → @Parameters @ApiModel → @Schema @ApiModelProperty(hidden = true) → @Schema(accessMode = READ_ONLY) @ApiModelProperty → @Schema @ApiOperation(value = “foo”, notes = “bar”) → @Operation(summary = “foo”, description = “bar”) @ApiParam → @Parameter @ApiResponse(code = 404, message = “foo”) → @ApiResponse(responseCode = “404”, description = “foo”) sudo apt-get install docker-ce=\u003c5:20.10.12~3-0~ubuntu-focal\u003e docker-ce-cli=\u003cVERSION_STRING\u003e containerd.io ","date":"2022-02-14","objectID":"/springdoc/:4:0","tags":null,"title":"SpringBoot生成OpenAPI 3.0文档","uri":"/springdoc/"},{"categories":null,"content":"Docker learning script Docker 目前存在多个国内镜像，以阿里云网易云为主，可以选定永久的和临时的。加速服务需要去对应的网站选择，随后按照步骤配置进入本机 配置文档位于/etc/sysconfig/docker,，重启检查是否生效service docker restart. 运行hello world sample ","date":"2021-12-05","objectID":"/docker/:0:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"基础命令 docker build docker pulldocker run ","date":"2021-12-05","objectID":"/docker/:1:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"docker为什么快 容器，是一个运行时环境，也就是集装箱。比VM快的原因： 有更少抽象层，不需要HyperVisor实现硬件资源虚拟化，因此运行效率更高 利用宿主机的内核，而不需要Guest OS。当新建一个虚拟机时， 虚拟机需要重新加载一个操作系统内核。而docker直接利用宿主机内核，因此加载速度极快。 ","date":"2021-12-05","objectID":"/docker/:2:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"docker 常用命令 ","date":"2021-12-05","objectID":"/docker/:3:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"镜像命令 鲸鱼背上有大海 蓝色的大海中 »»\u003e 宿主机系统 鲸鱼 »»\u003e docker 集装箱 »»\u003e 容器实例 from 来自我们能的镜像模板 docker images 列出本地主机的镜像 可以使用唯一ID和仓库名来管理 -a 列出本地所有的镜像（含中间镜像层）-q 只显示当前镜像的id--digests 描述消息--no-trunc 显示完整信息 docker search 搜索某个镜像名字 搜索网站为docker hub docker pull 从官方抓取镜像 没写版本号，代表直接抓取最新版本 docker pull tomact 等价 docker pull tomcat:latest -docker rmi 移除镜像，remove images -f 强制删除 docker rmi -f 镜像ID docker rmi -f 镜像名1：tag 镜像名2：tag 删除全部docker rmi -f $(docker images -qa) 子命令解释，查询出docker所有镜像id，并删除 ","date":"2021-12-05","objectID":"/docker/:3:1","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"容器命令 可以把容器看为一个简易版的Linux系统。有镜像才能创建容器，这是一个根本性的前提 新建并启动容器 docker run [options] image [command] –name 重命名,将容器名 docker run -it --name mycentos centos 将centos重命名为mycentos -i 以交互模式运行容器，通常与-t同时使用 -t 为容器重新分配一个伪输入终端，通常-i同时使用 查看容器 docker ps查看当前所有进程 -a 列出所有正在运行的容器+历史上运行过的 -l 最后一次运行的 -n 显示最近n个创建的容器 -q 静默模式，只显示容器编号 以上命令都可以组合使用 容器重命名 docker rename oldName newName 对部分容器重新命名 启动容器 当一个容器关闭后要想重新启动时，采用start命令 docker start 容器ID或者容器名 退出容器 exit容器停止退出 ctrl + p + q容器不停止退出 重启容器 docker restart ID 关闭容器 kill 直接删除掉该进程 stop 温柔一些的停止 删除容器 docker rm 容器ID -f 强制删除 一次性删除多个镜像 docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm 运行容器 该命令启动守护式容器 docker run -d centos 使用centos：latest，以后台模式启动一个容器 前台启动，交互形式-it 日志打印 docker logs 查看容器内的运行进程 docker top 用户id 查看容器内部细节 docker inspect 容器id 重新进入容器内环境 此时的容器正在运行中，如果需要进入则采用exec和attach命令。 退出后进入容器，exec和attach的区别 attach 进入已经启动的容器终端，不会启动新的进程 docker attach 容器id exec 是在容器中打开新的终端，并且可以启动新的进程 docker exec -t 容器id ls -l /tmp 容器内拷贝文件到本机 docker cp 容器ID 基本路径 从主机复制到容器sudo docker cp host_path containerID:container_path 从容器复制到主机sudo docker cp containerID:container_path host_path ","date":"2021-12-05","objectID":"/docker/:3:2","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"Docker镜像 UnionFS 联合文件系统，是一种分层、轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加。 好处 共享资源，如果有多个镜像都从base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像。 特点 镜像都是只读的，这一层通常称作容器层，容器层之下的称作镜像层 commit命令 docker commit 提交容器副本使之成为一个新的镜像 docker commit -m =\"提交的描述信息\" -a=\"作者\" 容器ID要创建的目标镜像名:[标签名] docker commit -m =\"description\" -a=\"author\" newName:1.2 docker run -it -p 8080:8080 tomcat -p 本地端口:docker端口 -P 随机分配端口 ","date":"2021-12-05","objectID":"/docker/:4:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"容器数据卷 为了放置删除镜像后数据丢失，保存数据，使用卷，完全独立于容器之外的 完全容器的持久化，容器间继承+共享数据 ","date":"2021-12-05","objectID":"/docker/:4:1","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"数据卷 容器内添加：直接命令添加，DockerFile添加 直接命令添加 docker run -it -v /宿主机绝对路径目录：/容器目录 镜像名 OS X系统链接必须采用绝对路径，以及将/var添加进docker设置中的resources\u003efile sharing docker run -it -v /Users/weivang/dataVolume:/datalum centos 带权限的命令 docker run -it -v /宿主机绝对路径目录：/容器目录:ro 镜像名 该命令进入之后，不可进行写操作，仅可读操作 验证映射链接成功 docker inspect 容器id ","date":"2021-12-05","objectID":"/docker/:4:2","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"DockerFile添加 根目录下新建一个DockerFile文件，使用Volume指令添加 使用DockerFile是出于可移植和分享的考虑;由于宿主机目录是依赖于特定宿主机的，并不能保证所有的宿主机都存在这样的特定目录。 DockerFile文件 # DockerFile构建 FROM centos VOLUME [\"/dataVolume1\",\"/dataVolume2\"] CMD echo \"finished，-----successed\" CMD echo \"finished，-----successed\" 文件构建命令docker build -f 使用dockerfile构建的容器自动挂载的数据卷，docker会在宿主机目录自动生成对应的文件 ","date":"2021-12-05","objectID":"/docker/:4:3","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"数据卷容器 其他容器可以通过已经挂载在父容器上的数据卷实现数据共享，挂载数据卷的容器，称之为数据卷容器。 实现数据共享，一条绳上的蚂蚱。 -volumes-from复制容器数据卷 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止 ","date":"2021-12-05","objectID":"/docker/:4:4","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"DockerFile解析 Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 基础知识 每条保留字指令都必须为大写字母，且后面要跟随至少一个参数 从上到下，顺序执行 大致流程 从基础镜像运行一个容器 执行一条指令对容器进行修改。 从应用软件的角度来看，DockerFile、Docker镜像与Docker容器分别代表软件的三个不同阶段。 DockerFile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件的运行态 DockerFile体系结构，保留字指令 FROM 基础镜像 MAINTAINER 维护者 RUN 执行的命令 EXPOSE 暴露接口 WORKDIR 工作目录，终端默认登录之后的工作目录 ENV 用来在构建镜像过程中设置环境变量 ADD 拷贝+解压缩 COPY 复制 VOLUME 容器数据卷 CMD 容器启动时要运行的命令 ENTRYPOINT 指定一个容器时要运行的命令,ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数 ONBUILD 父镜像在子镜像被继承后，父镜像的onbuild被触发 案例 自定义一个centos镜像，使得镜像mycentos自己的镜像具备如下： 登录后的默认路径 vim编辑器 查看网络配置ifconfig支持 FROM CENTOS ENV mypath /tmp WORKDIR $mypath RUN yum -y install vim RUN yun -y install net-tools EXPOSE 80 CMD echo $mypath CMD echo \"success ----- ok\" CMD /bin/bash 构建，docker build -t 新镜像名字:tag .，注：最后的 . 代表本次执行的上下文路径，下一节会介绍。 运行，docker run -it 新镜像名字:tag 列出镜像的变更历史，docker history 镜像名 CMD和entrypoint的区别 ","date":"2021-12-05","objectID":"/docker/:5:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"安装mysql及使用 docker search mysql docker pull mysql:5.6 docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 除了这种方式外，还可以挂载数据卷，以mac为例，Linux同样的操作，就是要注意路径为绝对路径不然容易出错 docker run -p 3306:3306 -v /Users/weivang/DataVolume/mysql:/var/lib/mysql --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 停止mysql之后，使用restart命令重新进入 docker restart 容器id ","date":"2021-12-05","objectID":"/docker/:6:0","tags":null,"title":"Docker笔记","uri":"/docker/"},{"categories":null,"content":"创建conda环境，激活其他虚拟环境时报错 今天本来正常从github找到一个项目，打算按照常规操作跑起来看看结果，结果一下子出现一堆报错，一下子慌了神，bing（必应）了半天总算找到症结所在。 ","date":"2021-12-05","objectID":"/condafix/:0:0","tags":null,"title":"conda报错：An unexpected error has occurred. Conda has prepared the above report. Upload did not complete.","uri":"/condafix/"},{"categories":null,"content":"问题复现 创建环境、切换环境时，出现以下报错信息： C:\\Users\\windows\u003econda create -n na python=3.6 Collecting package metadata (current_repodata.json): failed # \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e ERROR REPORT \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c Traceback (most recent call last): File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\exceptions.py\", line 1079, in __call__ return func(*args, **kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\main.py\", line 84, in _main exit_code = do_call(args, p) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\conda_argparse.py\", line 83, in do_call return getattr(module, func_name)(args, parser) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\main_create.py\", line 41, in execute install(args, parser, 'create') File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\install.py\", line 261, in install unlink_link_transaction = solver.solve_for_transaction( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 114, in solve_for_transaction unlink_precs, link_precs = self.solve_for_diff(update_modifier, deps_modifier, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 157, in solve_for_diff final_precs = self.solve_final_state(update_modifier, deps_modifier, prune, ignore_pinned, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 262, in solve_final_state ssc = self._collect_all_metadata(ssc) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\common\\io.py\", line 88, in decorated return f(*args, **kwds) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 425, in _collect_all_metadata index, r = self._prepare(prepared_specs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\", line 1020, in _prepare reduced_index = get_reduced_index(self.prefix, self.channels, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\index.py\", line 288, in get_reduced_index new_records = SubdirData.query_all(spec, channels=channels, subdirs=subdirs, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 140, in query_all result = tuple(concat(executor.map(subdir_query, channel_urls))) File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\", line 611, in result_iterator yield fs.pop().result() File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\", line 439, in result return self.__get_result() File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\", line 388, in __get_result raise self._exception File \"D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\thread.py\", line 57, in run result = self.fn(*self.args, **self.kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 132, in \u003clambda\u003e subdir_query = lambda url: tuple(SubdirData(Channel(url), repodata_fn=repodata_fn).query( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 145, in query self.load() File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 209, in load _internal_state = self._load() File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 371, in _load raw_repodata_str = fetch_repodata_remote_request( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\", line 694, in fetch_repodata_remote_request resp = session.get(join_url(url, filename), headers=headers, proxies=session.proxies, File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\", line 555, in get return self.request('GET', url, **kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\", line 542, in request resp = self.send(prep, **send_kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\", line 655, in send r = adapter.send(request, **kwargs) File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\adapters.py\", line 439, in send resp = conn.urlopen( File \"D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\connectionpool.py\", line 696, ","date":"2021-12-05","objectID":"/condafix/:1:0","tags":null,"title":"conda报错：An unexpected error has occurred. Conda has prepared the above report. Upload did not complete.","uri":"/condafix/"},{"categories":null,"content":"解决方案 出现这个问题后，有比较多的解决方案： 使用命令清理缓存，conda clean -i 删除 ~/.condarc (C:\\Users\\admin) 关闭梯子（大杀招） 反正就是让人头大，解决方案希望对大家有用 ","date":"2021-12-05","objectID":"/condafix/:2:0","tags":null,"title":"conda报错：An unexpected error has occurred. Conda has prepared the above report. Upload did not complete.","uri":"/condafix/"},{"categories":null,"content":"Linux常用命令 一些感想 ","date":"2021-12-04","objectID":"/reading/:0:0","tags":null,"title":"Reading","uri":"/reading/"},{"categories":null,"content":"测试 ","date":"2021-12-04","objectID":"/reading/:1:0","tags":null,"title":"Reading","uri":"/reading/"},{"categories":null,"content":"第一次部署网站\u0026一些想法 ","date":"2021-11-21","objectID":"/first/:0:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"一些废话 虽然这个标题叫“第一次部署网站”，但其实我私下里已经部署过另外一个博客了，所以实际上是第二次。之前部署的博客是基于halo这个动态博客框架，为什么会放弃这个已经部署好的网站，而选择另外的框架呢？ 主要原因是我比较折腾，halo提供的博客系统其实非常完善了，提供了完善的前后台管理，评论系统，搜索等功能，本来我也非常喜欢的。 但是有一个缺点我不太能接受，它需要登录到博客系统后台才能开始写文章，当然你也可以在本地创作完稿子，再把它复制粘贴到后台，然后发布。这个操作也不是不行，对于喜欢本地Markdown创作，然后push到博客上的同学来说，感觉比较别扭。 其实，最为主要的原因是动态博客需要服务器来进行部署，服务器虽然不是太贵，以腾讯云的轻量云服务器来说，第一次购买一年74元，再搭上一个域名，小两百就没了，所以能白嫖就白嫖。 静态博客系统相比于动态博客的优点在于网站部署可以完全不用服务器，也就是说可以省掉74块钱乃至更多，毕竟服务器续费需要花更多钱。 ","date":"2021-11-21","objectID":"/first/:1:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"正文 部署一个不花钱的博客，有比较多的选项，常用的Github Pages + Hugo/Hexo 等其他静态博客系统，如果觉得Github访问过慢，可以采用国内的Gitee Pages，又或者使用其他云服务商提供的CDN加速。 个人推荐使用Hugo来构建自己的博客，倒也没啥太大的原因，就是因为我的电脑不能安装Hexo，就弃坑了（O(∩_∩)O哈哈~）。Hugo也很强大，Github 关注55.6k，而Hexo只有33.8k，用就用最热门的，出bug了也方便找。下面是部署使用的一些环境： 操作系统采用 Ubuntu 20.04 LTS，博客系统采用Hugo，静态托管使用Github Pages。 ","date":"2021-11-21","objectID":"/first/:2:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"Hugo安装和配置 Hugo的安装比较简单，Windows平台需要进入Hugo官网下载Hugo，Ubuntu只需要在终端输入以下命令： sudo apt-get install hugo 不确定是否安装完成，可以验证一下： hugo version 确认安装完成之后，找到一个喜欢的目录 hugo new site myfirstblog 运行以上的命令会生成一个myfirstblog文件夹，请熟记这个目录，他就是以后的大本营，可千万别给删了，这个文件夹里包含了博客系统的所有文件。 创建完一个博客项目后，去官网选一个喜欢的主题 cd myfirstblog git clone https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 在这里，我选择了一个比较经典的主题–PaperMod，使用git clone的方式下载themes文件夹中。每一个主题都有自己特有的配置，为了让这些配置生效，需要将它们写入到配置文档中。 Hugo提供了一个文档config.toml来编写自己的主题设置，该文件位于主目录下，以PaperMod主题为例，官方会提供一个完整的配置示例，在初期我们只要将这个配置复制粘贴就可以用了，后期上手之后可以做更多定制化的内容，配置如下： baseURL: \"https://examplesite.com/\" title: ExampleSite paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: ExampleSite description: \"ExampleSite description\" keywords: [Blog, Portfolio, PaperMod] author: Me # author: [\"Me\", \"You\"] # multiple authors images: [\"\u003clink or path of image for opengraph, twitter-cards\u003e\"] DateFormat: \"January 2, 2006\" defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \"\u003clink / abs url\u003e\" favicon16x16: \"\u003clink / abs url\u003e\" favicon32x32: \"\u003clink / abs url\u003e\" apple_touch_icon: \"\u003clink / abs url\u003e\" safari_pinned_tab: \"\u003clink / abs url\u003e\" label: text: \"Home\" icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \"This is subtitle\" imageUrl: \"\u003cimg location\u003e\" imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \"Hi there \\U0001F44B\" Content: Welcome to my blog socialIcons: - name: twitter url: \"https://twitter.com/\" - name: stackoverflow url: \"https://stackoverflow.com\" - name: github url: \"https://github.com/\" analytics: google: SiteVerificationTag: \"XYZabc\" bing: SiteVerificationTag: \"XYZabc\" yandex: SiteVerificationTag: \"XYZabc\" cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \"https://github.com/\u003cpath_to_repo\u003e/content\" Text: \"Suggest Changes\" # edit text appendFilePath: true # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\"title\", \"permalink\", \"summary\", \"content\"] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 # Read: https://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma # pygmentsUseClasses: true # markup: # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai 上面的操作完成了骨干的构建，下面开始完善博客的血肉，即文章内容，创建一篇新的文章采用以下命令： hugo new post/first.md 当前上面的操作准备就绪后，可以使用Hugo的功能进行本地预览 hugo server 开启服务后，在浏览器输入http://localhost:1313即可进入网站，在网站中可以看见刚下载好的主题和创建的第一篇文章。至此，Hugo的初步搭建就完成了，使用下面的命令可以完成Hugo的生产环境搭建： hugo -D ","date":"2021-11-21","objectID":"/first/:3:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"Github Pages配置 完成上面的工作之后，就可以进行下面的工作，将自己的静态博客部署到Github Pages上，实现全网访问(理论上，受限于国内的网络)。 进入Github官网，点击右上方的\"+”，新建一个仓库，仓库名为\"xxx.github.io”，第一个xxx必须为用户的昵称，没有商量的余地。比如我的Github用户名为\"dancingmonkey”，那么仓库名就为\"dancingmonkey.github.io”，这个极容易出错，不按照命名规则来，可能就要花很长时间来debug了。 仓库创建好之后，将博客目录下的public文件夹中的所有内容上传到该仓库： cd public git init git commit -m \"first commit\" git remote add origin 仓库名 git push -u origin master 如果按照步骤来的话，每个配置都保持一致，那么这个时候你的博客就可以在全网访问了。追求更好的用户体验可以购买一个域名，在域名提供商的DNS解析处，将域名解析到对应的Github仓库名。同时，还需要在仓库的设置页面中，找到Pages设置项，在其中的Custom Domain(自定义域名)处输入自己购买的域名。 至此，使用Hugo和Github Pages搭建一个免费的静态博客就完成了，唯一需要额外花费的就是域名了。 ","date":"2021-11-21","objectID":"/first/:4:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"},{"categories":null,"content":"一些感想 花了很长的时间才把网站部署起来，一方面是懒，云服务器买了，域名也买了，啥都齐了，但就是没把博客搞起来。现在回想起来，实际用来部署网站时间的，也就1个小时，剩下的时间都在找bug了。总是不相信别人的教程，每次都偏离一点路线，然后就出大错了。总结下来，一定要按步骤来，在复现结果之后在开始玩其他花样，还没有复现就开始玩花样等于找死。 ","date":"2021-11-21","objectID":"/first/:5:0","tags":null,"title":"第一次部署网站\u0026一些想法","uri":"/first/"}]