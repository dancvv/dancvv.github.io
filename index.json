
[{"content":"","date":"2026年02月13日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2026年02月13日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"说实话，朋友刚推荐《沉眠的牢狱》时，我其实是无所谓的。作为一个总结怪，喜欢透过事实看本质，所以一开始对他有轻蔑的想法，一直也没有动手读。即使后面打开这本书的时候想法也没有改变，我其实是抱着一种“做几道逻辑题醒醒脑”的心态打开的。\n毕竟作为一名程序员，我每天的工作就是处理逻辑：输入A，经过函数B，必然得到结果C。我想，三个男人被关在一个核避难所里，为了逃生必须供认谁是凶手——这不就是经典的“囚徒困境”模型吗？我甚至在脑子里准备好了博弈论的收益矩阵，准备像查Bug一样，通过他们的供词矛盾点，快速定位那个“异常变量”（凶手）。\n但我大意了。读完最后一页，我感觉我的大脑直接蓝屏了。\n首先，我要吐槽一下浦贺和宏的“代码风格”。这书居然没有章节划分？整本书就像是一段写在 while(true) 死循环里的代码，没有注释，没有断点，甚至不给读者留出喘息（Garbage Collection）的时间。这种高密度的文本流，带来了一种极强的压迫感，让我本来想睡前读半小时，结果硬生生熬到了凌晨，因为根本找不到“暂停键”。\n从技术角度看，这本书最让我惊喜（也最让我头秃）的地方，在于它对“逻辑”的嘲弄。\n在我的职业习惯里，系统是不会撒谎的，Log（日志）记录了什么，事实就是什么。但在《沉眠的牢狱》这个系统里，所有的“输入端”——也就是角色的记忆和供词，都是不可靠的。\n我一直在试图用线性的逻辑去推导真相，试图理清时间轴，试图判断谁在说谎。但读到后面我才发现，作者利用了我们对“叙述者”的盲目信任，植入了一个底层的逻辑炸弹。当那个核心诡计揭开的时候——比如你以为的交换杀人对象其实是同一个人，你以为的男性叙述者“我”其实是个女性，你以为的遗书其实是伪造的——我那种感觉就像是：我辛辛苦苦排查了三天的代码逻辑，最后发现是编译器本身被黑客篡改了。\n这种“被降维打击”的感觉，虽然挫败，但也真的爽。它打破了我作为理工男的一种傲慢——我认为世界是可以被计算的，但在极端的人性面前，所有的算法都会失效。\n总结一下： 这本书对我来说，不是一个待解的谜题，而是一个设计精妙的“思维陷阱”。它提醒我，在代码的世界里，0就是0，1就是1；但在人的世界里，记忆可以被篡改，真相可以被折叠，有时候“相信”本身，就是最大的Bug。\n很感谢朋友的推荐，虽然读完有点致郁，但这种大脑被“重构”的感觉确实很过瘾。\n","date":"2026年02月13日","externalUrl":null,"permalink":"/posts/%E6%B2%89%E7%9C%A0%E7%9A%84%E7%89%A2%E7%AC%BC/","section":"Posts","summary":"","title":"沉眠的牢笼读书小记","type":"posts"},{"content":"","date":"2026年02月13日","externalUrl":null,"permalink":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","section":"Tags","summary":"","title":"读书笔记","type":"tags"},{"content":"欢迎来到我的个人博客!\n这里记录着我的技术学习、生活感悟和随笔。\n","date":"2026年02月13日","externalUrl":null,"permalink":"/","section":"欢迎来到 Luobottle 的博客","summary":"","title":"欢迎来到 Luobottle 的博客","type":"page"},{"content":"","date":"2026年02月13日","externalUrl":null,"permalink":"/tags/%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4/","section":"Tags","summary":"","title":"推理小说","type":"tags"},{"content":"","date":"2022年03月10日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2022年03月10日","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":" 写在前面 # 在接触到Docker之后，发现他火起来不是没有道理的，极大的简化了安装过程，特别是本机还有一些老旧项目的数据库，但是又不能直接删掉弄新的。最近学习一个项目，需要安装各种数据，像MySQL，MongoDB之类的安装，只需要几个命令就能轻松搞起来。下面我会分章来讲解怎么利用Docker安装MySQL和MongoDB。\nMySQL安装 # 选择版本 选择需要安装的版本，可以直接在命令输入docker search mysql查询可用的版本，或者上docker hub上查询；\n拉取镜像 默认拉去最新版本的镜像\ndocker pull mysql:latest 3.查看本地镜像 使用images命令查看是否拉取下来：\ndocker images 运行容器 使用run命令运行MySQL容器： docker run -itd --name localsql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 参数说明：\n-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。 MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。 还可以做一个改进，如果直接在容器内存放数据，一旦容器被误删，数据在没有做备份的情况下直接就丢失了，所以docker使用容器卷技术进行数据分离，类似于共享的概念。添加数据卷命令如下：\ndocker run -d --name localsql -v /data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql 检查运行进程 运行完成之后使用docker ps检查使用成功运行。 MongoDB安装 # MongoDB的安装和MySQL的安装大同小异，因此下文对其具体操作进行简述，详细操作参照上节。\n选择版本 选择需要安装的版本，可以直接在命令输入`docker search mogond查询可用的版本，或者上docker hub上查询；\n拉取镜像 默认拉去最新版本的镜像\ndocker pull mongo:latest 3.查看本地镜像 使用images命令查看是否拉取下来：\ndocker images 运行容器 使用run命令运行MySQL容器： docker run -itd --name localmongo -p 27017:27017 -e mongo 参数说明：\n-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。 MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。 还可以做一个改进，如果直接在容器内存放数据，一旦容器被误删，数据在没有做备份的情况下直接就丢失了，所以docker使用容器卷技术进行数据分离，类似于共享的概念。添加数据卷命令如下：\ndocker run -itd -p 27017:27017 -v /data/mongo:/data/db --name localmongo mongo 在上面的命令中，几个命令参数的详细解释如下：\n-p 映射容器服务的 27017 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务 -v 为设置容器的挂载目录，这里是将本机的“/data/mongo”目录挂载到容器中的/data/db中，作为 mongodb 的存储目录 检查运行进程 运行完成之后使用docker ps检查使用成功运行。 ","date":"2022年03月10日","externalUrl":null,"permalink":"/posts/docker-utils/","section":"Posts","summary":"","title":"Docker安装常用的数据库","type":"posts"},{"content":"","date":"2022年03月10日","externalUrl":null,"permalink":"/tags/mongodb/","section":"Tags","summary":"","title":"MongoDB","type":"tags"},{"content":"","date":"2022年03月10日","externalUrl":null,"permalink":"/tags/mysql/","section":"Tags","summary":"","title":"MySQL","type":"tags"},{"content":"","date":"2022年03月10日","externalUrl":null,"permalink":"/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/","section":"Categories","summary":"","title":"技术教程","type":"categories"},{"content":"","date":"2022年03月10日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Tags","summary":"","title":"数据库","type":"tags"},{"content":"","date":"2022年03月10日","externalUrl":null,"permalink":"/tags/%E8%BF%90%E7%BB%B4/","section":"Tags","summary":"","title":"运维","type":"tags"},{"content":"LeetCode 1356，题目链接\n代码如下：\nclass Solution { public int[] sortByBits(int[] arr) { // 巧妙的解法 // 利用java自身携带的统计函数 for(int i=0; i\u0026lt;arr.length; i++){ arr[i] = Integer.bitCount(arr[i]) * 1000000 + arr[i]; } Arrays.sort(arr); // 排序完之后对数组进行取余操作，得到原来的数组 for(int i=0; i\u0026lt;arr.length; i++){ arr[i] = arr[i] % 1000000; } return arr; } } ","date":"2022年03月06日","externalUrl":null,"permalink":"/posts/leetcode-1356/","section":"Posts","summary":"","title":"[Leetcode 1356] 统计数字在二进制下1的数目排序","type":"posts"},{"content":"","date":"2022年03月06日","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2022年03月06日","externalUrl":null,"permalink":"/tags/leetcode/","section":"Tags","summary":"","title":"LeetCode","type":"tags"},{"content":"","date":"2022年03月06日","externalUrl":null,"permalink":"/tags/%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"排序","type":"tags"},{"content":"","date":"2022年03月06日","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2022年03月06日","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/","section":"Categories","summary":"","title":"算法题解","type":"categories"},{"content":"","date":"2022年03月06日","externalUrl":null,"permalink":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/","section":"Tags","summary":"","title":"位运算","type":"tags"},{"content":"","date":"2022年03月02日","externalUrl":null,"permalink":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/","section":"Tags","summary":"","title":"哈希表","type":"tags"},{"content":"","date":"2022年03月02日","externalUrl":null,"permalink":"/tags/%E9%93%BE%E8%A1%A8/","section":"Tags","summary":"","title":"链表","type":"tags"},{"content":"面试题 02.07 链表相交，题目链接点我\n这个题我先用了最耗时的方法做，既然是让最第一个相交的节点，也就是说，找到第一个相等的点。既然是相等，那么我把一个链表的所有节点存到一个哈希表中，让后让第二个链表在遍历的同时，不停确认哈希表中是不是有这个节点，如果有，终止循环，找到节点，没有就返回null。\n代码如下：\npublic class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode cross = null; ListNode loopA = headA; ListNode loopB = headB; if(headA ==null || headB ==null) return cross; Map\u0026lt;ListNode,Integer\u0026gt; hash = new HashMap\u0026lt;\u0026gt;(); while(loopA != null){ hash.put(loopA,loopA.val); loopA = loopA.next; } while(loopB != null){ if(hash.containsKey(loopB)){ cross = loopB; // 条件符合之后需要跳出循环 break; } loopB = loopB.next; } return cross; } } 也有十分巧妙的解法，两个链表如果相交，遍历完a后，紧接着遍历b，另一个链表b采取同样的操作，遍历完b，然后遍历a，他们会在相等的位置停下。因为a+b=b+a，其长度一致，转一圈终究会回到共同的点。如果两个链表没有相交的点，A的长度是a，B的长度是b，如果两者不相交，则两链的头结点在同时走了a+b步后均会指向null，即满足了循环的终止条件。\n代码如下：\npublic class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode a = headA, b = headB; // A的长度是a，B的长度是b，如果两者不相交，则两链的头结点在同时走了a+b步后均会指向null，即满足了循环的终止条件。 while(a != b){ a = a != null ? a.next : headB; b = b != null ? b.next : headA; } return a; } } ","date":"2022年03月02日","externalUrl":null,"permalink":"/posts/offer-07/","section":"Posts","summary":"","title":"面试题 02.07 链表相交","type":"posts"},{"content":"LeetCode 537，题目链接点我\n这个题一开始想到了暴力破解的方式，利用两层for循环，以第一层为起点，在第二层里面不断累加，如果和大于等于target，记录当前长度，并与之前的长度做对比，然后结束第二层循环。不断的进行此操作就可以拿到结果。\n代码如下：\nclass Solution { public int minSubArrayLen(int target, int[] nums) { // 暴力破解 int res = Integer.MAX_VALUE; for(int i=0; i\u0026lt;nums.length; i++){ int sum = 0; for(int j=i; j\u0026lt;nums.length; j++){ sum += nums[j]; if(sum \u0026gt;= target){ int subLen = j-i+1; res = res \u0026gt; subLen ? subLen : res; break; } } } // 此处判断结果是否变过 return res == Integer.MAX_VALUE ? 0 : res; } } ","date":"2022年02月28日","externalUrl":null,"permalink":"/posts/leetcode-209/","section":"Posts","summary":"","title":"[LeetCode 209] 长度最小的子数组","type":"posts"},{"content":"","date":"2022年02月28日","externalUrl":null,"permalink":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","section":"Tags","summary":"","title":"滑动窗口","type":"tags"},{"content":"","date":"2022年02月28日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E7%BB%84/","section":"Tags","summary":"","title":"数组","type":"tags"},{"content":"LeetCode 2106，题目链接点我\n这个题虽然是个简单题，但是我还是花了一点时间来解答，猛的想错了方向，差点没绕出来。其实，还是很简单的，只需要采用一个for循环外加两个条件判断即可。\n在循环内，我们首先要知道这个数组的最小值，那么简单的if判断就能找到最小值。现在的问题怎么找到第二个数，使得两者之间的差值最大。题目要求第二个数必须在第一个数后面，也就是说两个数的序号必须是一前一后，前面的数小于后面的数。\n思路有了，代码如下：\nclass Solution { public int maximumDifference(int[] nums) { int diff = -1; int min = nums[0]; for(int i=1;i\u0026lt;nums.length;i++){ // 找到最小值 if(min \u0026gt; nums[i]){ min = nums[i]; }else if(nums[i]\u0026gt;min){ // 判断差值是否小于当前差值,同时，相减的两个数不能相等 diff = Math.max(diff, nums[i] - min); } } return diff; } } ","date":"2022年02月26日","externalUrl":null,"permalink":"/posts/leetcode-2106/","section":"Posts","summary":"","title":"[LeetCode 2106] 增量元素之间的最大差值","type":"posts"},{"content":"","date":"2022年02月26日","externalUrl":null,"permalink":"/tags/%E8%B4%AA%E5%BF%83/","section":"Tags","summary":"","title":"贪心","type":"tags"},{"content":"LeetCode 1523，题目链接点我\n一行代码解决\nhigh加一是为了补上缺失的那一个，[0,x]范围的奇数必定为x的一半。如果x为奇数，比如7，根据Java的规则只能拿到3，实际有4个，就是把7给漏了，所以要加1.\n代码如下：\nclass Solution { public int countOdds(int low, int high) { return (high+1)/2 - low/2; } } ","date":"2022年02月25日","externalUrl":null,"permalink":"/posts/leetcode-1523/","section":"Posts","summary":"","title":"[LeetCode 1523] 在区间范围内统计奇数数目","type":"posts"},{"content":"","date":"2022年02月25日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6/","section":"Tags","summary":"","title":"数学","type":"tags"},{"content":"LeetCode 537，题目链接点我\n这个题涉及到数学中复变函数的运算，也很简单，没有涉及到复杂运算，仅实现复数乘法。它的难处在于如何让两个字符串实现乘法运算。\n简单科普一下复数乘法，两个复数的和依然是复数，它的实部是原来两个复数实部的和，它的虚部是原来两个虚部的和。复数的加法满足交换律和结合律。\n根据复数乘法的规则，我们首先需要取到实部和虚部，这个可利用String类的split()方法，把一个代表复数的字符串分解为实部和虚部的字符数组。得到转换后的字符数组，我们将每个字符转换为整数，根据复数规则，进行分解运算。\n分解运算具体步骤： $(a+bi)(c+di)=(ac-bd)+(ad+b*c)i$\n把分解运算的结果按照指定的字符串形式返回，代码如下：\nclass Solution { public String complexNumberMultiply(String num1, String num2) { String[] ss1 = num1.split(\u0026#34;\\\\+|i\u0026#34;), ss2 = num2.split(\u0026#34;\\\\+|i\u0026#34;); int a = parse(ss1[0]), b = parse(ss1[1]); int c = parse(ss2[0]), d = parse(ss2[1]); int A = a * c - b * d, B = b * c + a * d; return A + \u0026#34;+\u0026#34; + B + \u0026#34;i\u0026#34;; } int parse(String s) { return Integer.parseInt(s); } } ","date":"2022年02月25日","externalUrl":null,"permalink":"/posts/leetcode-537/","section":"Posts","summary":"","title":"[LeetCode 537] 复数乘法","type":"posts"},{"content":"","date":"2022年02月25日","externalUrl":null,"permalink":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Tags","summary":"","title":"字符串","type":"tags"},{"content":"LeetCode 1706，题目链接点我\n拿到这个题之后，首先分析其限制条件。根据题意可以发现，球会在三个地方卡住，左右两侧的墙壁上，以及两侧挡板形成的V型槽。\n得到限制条件后，开始想怎么让程序找到路线，采用重力模拟的方法来实现。小球自上而下坠落，箱子已经按照二维数组的方式进行编码，那我们首先查第一列的小球，看它会不会成功走出小盒。也就是说采用两层for循环查找，第一层for循环用来演示每一列小球的位置，第二层for循环用来检验这一列小球会不会走出小盒。\n在第二层for循环里，我们需要判断这个小球是否满足走出去的条件，即开始分析的三个地方。这里的难点在于不太好分析为什么不会再V型槽处卡住，小球卡住的V型槽都在同一层。那么只需要记录当前小球的移动位置，小球在下一层的坐标，把这个坐标带到当前层来，两个方向不一致就会在同一层形成V型槽，就卡住了。\n代码如下：\nclass Solution { public int[] findBall(int[][] grid) { int n = grid[0].length; int[] result = new int[n]; for(int i=0 ; i\u0026lt;n ; i++){ int col = i; for(int[] nums:grid){ // 获取当前列的方向 int direction = nums[col]; // 移动后小球可能在的位置，左移一个，右移一个 col += direction; // 判断小球在不在界内，col为小球移动后的坐标 // 移动后的方向要求与上一个方向保持一致,一致就会形成V型槽 if(col\u0026lt;0 || col==n || nums[col] != direction){ col = -1; break; } } // 记录结果 result[i] = col; } return result; } } ","date":"2022年02月24日","externalUrl":null,"permalink":"/posts/leetcode-1706/","section":"Posts","summary":"","title":"[LeetCode 1706] 球会落何处","type":"posts"},{"content":"","date":"2022年02月24日","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E6%8B%9F/","section":"Tags","summary":"","title":"模拟","type":"tags"},{"content":"","date":"2022年02月14日","externalUrl":null,"permalink":"/tags/api%E6%96%87%E6%A1%A3/","section":"Tags","summary":"","title":"API文档","type":"tags"},{"content":"","date":"2022年02月14日","externalUrl":null,"permalink":"/tags/openapi/","section":"Tags","summary":"","title":"OpenAPI","type":"tags"},{"content":"","date":"2022年02月14日","externalUrl":null,"permalink":"/tags/springboot/","section":"Tags","summary":"","title":"SpringBoot","type":"tags"},{"content":" SpringBoot生成OpenAPI 3.0文档 # 概述 # 开发过程中需要写大量的接口文档，如果手写的话需要花费一定的时间，并且还需要额外的时间进行维护，为了避免这样的情况，开发人员可以引入文档管理工具进行自动生成。\n目前，可以生成RESTful风格文档最为成熟，规范且完整的框架是Swagger。国内局大部分人还在用过时的Swagger2，已于17年停止维护并更名为Swagger3。\n但是，本文并不会使用Swagger，而是使用与之类似的springdoc-openapi，这也是一个基于OpneAPI 3的Java库，帮助Spring boot工程自动生成API文档。在运行时检查应用程序，来推断基于spring配置，类结构和各种注释的API语义，同时，还支持Swagger-ui界面。\npom引入 # 整合spring-boot和swagger-ui，添加以下的依赖即可完成，不需要其他的设置\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这个依赖会自动部署swagger-ui到spring-boot应用：\n文档以HTML的形式展现 文档也可以yaml格式展现，路径如下：/v3/api-docs.yaml 文档设置 # swagger-ui路径 自定义访问路径 springdoc.swagger-ui.path=/swagger-ui.html swagger-ui开启 是否开启功能 springdoc.api-docs.enabled=true 简单的配置之后，启动项目，在本地端口加上自定义的路径就可以进入API接口文档。以默认项目8080端口为例，其访问路径为htttp://localhost:8080/swagger-ui.html\n注解迁移 # 从swagger2项目中迁移后，需要替换掉所有的swagger2注解：\n@Api → @Tag\n@ApiIgnore → @Parameter(hidden = true) or @Operation(hidden = true) or @Hidden\n@ApiImplicitParam → @Parameter\n@ApiImplicitParams → @Parameters\n@ApiModel → @Schema\n@ApiModelProperty(hidden = true) → @Schema(accessMode = READ_ONLY)\n@ApiModelProperty → @Schema\n@ApiOperation(value = \u0026ldquo;foo\u0026rdquo;, notes = \u0026ldquo;bar\u0026rdquo;) → @Operation(summary = \u0026ldquo;foo\u0026rdquo;, description = \u0026ldquo;bar\u0026rdquo;)\n@ApiParam → @Parameter\n@ApiResponse(code = 404, message = \u0026ldquo;foo\u0026rdquo;) → @ApiResponse(responseCode = \u0026ldquo;404\u0026rdquo;, description = \u0026ldquo;foo\u0026rdquo;)\nsudo apt-get install docker-ce=\u0026lt;5:20.10.123-0ubuntu-focal\u0026gt; docker-ce-cli=\u0026lt;VERSION_STRING\u0026gt; containerd.io\n","date":"2022年02月14日","externalUrl":null,"permalink":"/posts/springdoc/","section":"Posts","summary":"","title":"SpringBoot生成OpenAPI 3.0文档","type":"posts"},{"content":"","date":"2022年02月14日","externalUrl":null,"permalink":"/tags/swagger/","section":"Tags","summary":"","title":"Swagger","type":"tags"},{"content":"","date":"2022年02月14日","externalUrl":null,"permalink":"/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/","section":"Categories","summary":"","title":"后端开发","type":"categories"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/tags/devops/","section":"Tags","summary":"","title":"DevOps","type":"tags"},{"content":" Docker learning script # Docker 目前存在多个国内镜像，以阿里云网易云为主，可以选定永久的和临时的。加速服务需要去对应的网站选择，随后按照步骤配置进入本机\n配置文档位于/etc/sysconfig/docker,，重启检查是否生效service docker restart.\n运行hello world sample\n基础命令 # docker build docker pull docker run docker为什么快 # 容器，是一个运行时环境，也就是集装箱。比VM快的原因：\n有更少抽象层，不需要HyperVisor实现硬件资源虚拟化，因此运行效率更高 利用宿主机的内核，而不需要Guest OS。当新建一个虚拟机时， 虚拟机需要重新加载一个操作系统内核。而docker直接利用宿主机内核，因此加载速度极快。 docker 常用命令 # 镜像命令 # 鲸鱼背上有大海\n蓝色的大海中 \u0026raquo;\u0026raquo;\u0026gt; 宿主机系统 鲸鱼 \u0026raquo;\u0026raquo;\u0026gt; docker\n集装箱 \u0026raquo;\u0026raquo;\u0026gt; 容器实例 from 来自我们能的镜像模板\ndocker images 列出本地主机的镜像 可以使用唯一ID和仓库名来管理\n-a 列出本地所有的镜像（含中间镜像层） -q 只显示当前镜像的id --digests 描述消息 --no-trunc 显示完整信息 docker search 搜索某个镜像名字 搜索网站为docker hub\ndocker pull 从官方抓取镜像 没写版本号，代表直接抓取最新版本 docker pull tomact 等价 docker pull tomcat:latest\n-docker rmi\n移除镜像，remove images -f 强制删除 docker rmi -f 镜像ID docker rmi -f 镜像名1：tag 镜像名2：tag 删除全部docker rmi -f $(docker images -qa) 子命令解释，查询出docker所有镜像id，并删除\n容器命令 # 可以把容器看为一个简易版的Linux系统。有镜像才能创建容器，这是一个根本性的前提\n新建并启动容器 docker run [options] image [command]\n\u0026ndash;name 重命名,将容器名 docker run -it --name mycentos centos 将centos重命名为mycentos -i 以交互模式运行容器，通常与-t同时使用 -t 为容器重新分配一个伪输入终端，通常-i同时使用\n查看容器 docker ps查看当前所有进程\n-a 列出所有正在运行的容器+历史上运行过的 -l 最后一次运行的 -n 显示最近n个创建的容器 -q 静默模式，只显示容器编号 以上命令都可以组合使用\n容器重命名 docker rename oldName newName\n对部分容器重新命名\n启动容器 当一个容器关闭后要想重新启动时，采用start命令 docker start 容器ID或者容器名\n退出容器\nexit容器停止退出 ctrl + p + q容器不停止退出 重启容器 docker restart ID\n关闭容器 kill 直接删除掉该进程 stop 温柔一些的停止\n删除容器 docker rm 容器ID -f 强制删除 一次性删除多个镜像\ndocker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm 运行容器 该命令启动守护式容器 docker run -d centos\n使用centos：latest，以后台模式启动一个容器 前台启动，交互形式-it\n日志打印 docker logs\n查看容器内的运行进程 docker top 用户id\n查看容器内部细节 docker inspect 容器id\n重新进入容器内环境 此时的容器正在运行中，如果需要进入则采用exec和attach命令。\n退出后进入容器，exec和attach的区别 attach\n进入已经启动的容器终端，不会启动新的进程 docker attach 容器id exec 是在容器中打开新的终端，并且可以启动新的进程 docker exec -t 容器id ls -l /tmp\n容器内拷贝文件到本机 docker cp 容器ID 基本路径 从主机复制到容器sudo docker cp host_path containerID:container_path\n从容器复制到主机sudo docker cp containerID:container_path host_path Docker镜像 # UnionFS 联合文件系统，是一种分层、轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加。\n好处 共享资源，如果有多个镜像都从base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像。\n特点 镜像都是只读的，这一层通常称作容器层，容器层之下的称作镜像层\ncommit命令 docker commit 提交容器副本使之成为一个新的镜像\ndocker commit -m =\u0026quot;提交的描述信息\u0026quot; -a=\u0026quot;作者\u0026quot; 容器ID要创建的目标镜像名:[标签名] docker commit -m =\u0026quot;description\u0026quot; -a=\u0026quot;author\u0026quot; newName:1.2\ndocker run -it -p 8080:8080 tomcat -p 本地端口:docker端口 -P 随机分配端口\n容器数据卷 # 为了放置删除镜像后数据丢失，保存数据，使用卷，完全独立于容器之外的\n完全容器的持久化，容器间继承+共享数据\n数据卷 # 容器内添加：直接命令添加，DockerFile添加\n直接命令添加 docker run -it -v /宿主机绝对路径目录：/容器目录 镜像名 OS X系统链接必须采用绝对路径，以及将/var添加进docker设置中的resources\u0026gt;file sharing docker run -it -v /Users/weivang/dataVolume:/datalum centos 带权限的命令 docker run -it -v /宿主机绝对路径目录：/容器目录:ro 镜像名 该命令进入之后，不可进行写操作，仅可读操作\n验证映射链接成功 docker inspect 容器id DockerFile添加 # 根目录下新建一个DockerFile文件，使用Volume指令添加\n使用DockerFile是出于可移植和分享的考虑;由于宿主机目录是依赖于特定宿主机的，并不能保证所有的宿主机都存在这样的特定目录。\nDockerFile文件\n# DockerFile构建 FROM centos VOLUME [\u0026#34;/dataVolume1\u0026#34;,\u0026#34;/dataVolume2\u0026#34;] CMD echo \u0026#34;finished，-----successed\u0026#34; CMD echo \u0026#34;finished，-----successed\u0026#34; 文件构建命令docker build -f 使用dockerfile构建的容器自动挂载的数据卷，docker会在宿主机目录自动生成对应的文件\n数据卷容器 # 其他容器可以通过已经挂载在父容器上的数据卷实现数据共享，挂载数据卷的容器，称之为数据卷容器。\n实现数据共享，一条绳上的蚂蚱。\n-volumes-from复制容器数据卷\n容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止\nDockerFile解析 # Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。\n基础知识 每条保留字指令都必须为大写字母，且后面要跟随至少一个参数\n从上到下，顺序执行 大致流程 从基础镜像运行一个容器\n执行一条指令对容器进行修改。 从应用软件的角度来看，DockerFile、Docker镜像与Docker容器分别代表软件的三个不同阶段。\nDockerFile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件的运行态 DockerFile体系结构，保留字指令 FROM 基础镜像 MAINTAINER 维护者 RUN 执行的命令 EXPOSE 暴露接口 WORKDIR 工作目录，终端默认登录之后的工作目录 ENV 用来在构建镜像过程中设置环境变量 ADD 拷贝+解压缩 COPY 复制 VOLUME 容器数据卷 CMD 容器启动时要运行的命令 ENTRYPOINT 指定一个容器时要运行的命令,ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数 ONBUILD 父镜像在子镜像被继承后，父镜像的onbuild被触发\n案例 自定义一个centos镜像，使得镜像mycentos自己的镜像具备如下： 登录后的默认路径 vim编辑器 查看网络配置ifconfig支持\nFROM CENTOS ENV mypath /tmp WORKDIR $mypath RUN yum -y install vim RUN yun -y install net-tools EXPOSE 80 CMD echo $mypath CMD echo \u0026#34;success ----- ok\u0026#34; CMD /bin/bash 构建，docker build -t 新镜像名字:tag .，注：最后的 . 代表本次执行的上下文路径，下一节会介绍。\n运行，docker run -it 新镜像名字:tag 列出镜像的变更历史，docker history 镜像名\nCMD和entrypoint的区别\n安装mysql及使用 # docker search mysql docker pull mysql:5.6 docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 除了这种方式外，还可以挂载数据卷，以mac为例，Linux同样的操作，就是要注意路径为绝对路径不然容易出错 docker run -p 3306:3306 -v /Users/weivang/DataVolume/mysql:/var/lib/mysql --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 停止mysql之后，使用restart命令重新进入 docker restart 容器id ","date":"2021年12月05日","externalUrl":null,"permalink":"/posts/docker/","section":"Posts","summary":"","title":"Docker笔记","type":"posts"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/","section":"Categories","summary":"","title":"技术笔记","type":"categories"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/tags/%E5%AE%B9%E5%99%A8/","section":"Tags","summary":"","title":"容器","type":"tags"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"Tags","summary":"","title":"学习笔记","type":"tags"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/tags/conda/","section":"Tags","summary":"","title":"Conda","type":"tags"},{"content":" 创建conda环境，激活其他虚拟环境时报错 # 今天本来正常从github找到一个项目，打算按照常规操作跑起来看看结果，结果一下子出现一堆报错，一下子慌了神，bing（必应）了半天总算找到症结所在。\n问题复现 # 创建环境、切换环境时，出现以下报错信息：\nC:\\Users\\windows\u0026gt;conda create -n na python=3.6 Collecting package metadata (current_repodata.json): failed # \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; ERROR REPORT \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; Traceback (most recent call last): File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\exceptions.py\u0026#34;, line 1079, in __call__ return func(*args, **kwargs) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\main.py\u0026#34;, line 84, in _main exit_code = do_call(args, p) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\conda_argparse.py\u0026#34;, line 83, in do_call return getattr(module, func_name)(args, parser) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\main_create.py\u0026#34;, line 41, in execute install(args, parser, \u0026#39;create\u0026#39;) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\cli\\install.py\u0026#34;, line 261, in install unlink_link_transaction = solver.solve_for_transaction( File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\u0026#34;, line 114, in solve_for_transaction unlink_precs, link_precs = self.solve_for_diff(update_modifier, deps_modifier, File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\u0026#34;, line 157, in solve_for_diff final_precs = self.solve_final_state(update_modifier, deps_modifier, prune, ignore_pinned, File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\u0026#34;, line 262, in solve_final_state ssc = self._collect_all_metadata(ssc) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\common\\io.py\u0026#34;, line 88, in decorated return f(*args, **kwds) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\u0026#34;, line 425, in _collect_all_metadata index, r = self._prepare(prepared_specs) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\solve.py\u0026#34;, line 1020, in _prepare reduced_index = get_reduced_index(self.prefix, self.channels, File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\index.py\u0026#34;, line 288, in get_reduced_index new_records = SubdirData.query_all(spec, channels=channels, subdirs=subdirs, File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\u0026#34;, line 140, in query_all result = tuple(concat(executor.map(subdir_query, channel_urls))) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\u0026#34;, line 611, in result_iterator yield fs.pop().result() File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\u0026#34;, line 439, in result return self.__get_result() File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\_base.py\u0026#34;, line 388, in __get_result raise self._exception File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\concurrent\\futures\\thread.py\u0026#34;, line 57, in run result = self.fn(*self.args, **self.kwargs) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\u0026#34;, line 132, in \u0026lt;lambda\u0026gt; subdir_query = lambda url: tuple(SubdirData(Channel(url), repodata_fn=repodata_fn).query( File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\u0026#34;, line 145, in query self.load() File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\u0026#34;, line 209, in load _internal_state = self._load() File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\u0026#34;, line 371, in _load raw_repodata_str = fetch_repodata_remote_request( File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\conda\\core\\subdir_data.py\u0026#34;, line 694, in fetch_repodata_remote_request resp = session.get(join_url(url, filename), headers=headers, proxies=session.proxies, File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\u0026#34;, line 555, in get return self.request(\u0026#39;GET\u0026#39;, url, **kwargs) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\u0026#34;, line 542, in request resp = self.send(prep, **send_kwargs) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\sessions.py\u0026#34;, line 655, in send r = adapter.send(request, **kwargs) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\requests\\adapters.py\u0026#34;, line 439, in send resp = conn.urlopen( File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\connectionpool.py\u0026#34;, line 696, in urlopen self._prepare_proxy(conn) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\connectionpool.py\u0026#34;, line 964, in _prepare_proxy conn.connect() File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\connection.py\u0026#34;, line 359, in connect conn = self._connect_tls_proxy(hostname, conn) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\connection.py\u0026#34;, line 500, in _connect_tls_proxy return ssl_wrap_socket( File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\util\\ssl_.py\u0026#34;, line 432, in ssl_wrap_socket ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\site-packages\\urllib3\\util\\ssl_.py\u0026#34;, line 474, in _ssl_wrap_socket_impl return ssl_context.wrap_socket(sock) File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\ssl.py\u0026#34;, line 500, in wrap_socket return self.sslsocket_class._create( File \u0026#34;D:\\ProgramData\\Anaconda3\\lib\\ssl.py\u0026#34;, line 997, in _create raise ValueError(\u0026#34;check_hostname requires server_hostname\u0026#34;) ValueError: check_hostname requires server_hostname `$ D:\\ProgramData\\Anaconda3\\Scripts\\conda-script.py create -n na python=3.6` environment variables: CIO_TEST=\u0026lt;not set\u0026gt; CONDA_DEFAULT_ENV=tmc CONDA_EXE=D:\\ProgramData\\Anaconda3\\condabin\\..\\Scripts\\conda.exe CONDA_EXES=\u0026#34;D:\\ProgramData\\Anaconda3\\condabin\\..\\Scripts\\conda.exe\u0026#34; CONDA_PREFIX=D:\\ProgramData\\Anaconda3\\envs\\tmc CONDA_PREFIX_1=D:\\ProgramData\\Anaconda3 CONDA_PROMPT_MODIFIER=(tmc) CONDA_PYTHON_EXE=D:\\ProgramData\\Anaconda3\\python.exe CONDA_ROOT=D:\\ProgramData\\Anaconda3 CONDA_SHLVL=2 CURL_CA_BUNDLE=\u0026lt;not set\u0026gt; HOMEPATH=\\Users\\windows NODE_PATH=D:\\Program Files\\nodejs\\node_modules PATH=D:\\ProgramData\\Anaconda3;D:\\ProgramData\\Anaconda3\\Library\\mingw-w64\\bi n;D:\\ProgramData\\Anaconda3\\Library\\usr\\bin;D:\\ProgramData\\Anaconda3\\Li brary\\bin;D:\\ProgramData\\Anaconda3\\Scripts;D:\\ProgramData\\Anaconda3\\bi n;D:\\ProgramData\\Anaconda3\\envs\\tmc;D:\\ProgramData\\Anaconda3\\envs\\tmc\\ Library\\mingw-w64\\bin;D:\\ProgramData\\Anaconda3\\envs\\tmc\\Library\\usr\\bi n;D:\\ProgramData\\Anaconda3\\envs\\tmc\\Library\\bin;D:\\ProgramData\\Anacond a3\\envs\\tmc\\Scripts;D:\\ProgramData\\Anaconda3\\envs\\tmc\\bin;D:\\ProgramDa ta\\Anaconda3\\condabin;D:\\Program Files\\Python38\\Scripts;D:\\Program Files\\Python38;C:\\Program Files\\Eclipse Adoptium\\jdk-8.0.312.7-hotspot\\bin;C:\\Program Files\\Eclipse Foundation\\jdk-11.0.12.7-hotspot\\bin;D:\\Program Files (x86)\\VMware\\VMware Workstation\\bin;C:\\Program Files (x86)\\Common File s\\Oracle\\Java\\javapath;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\WINDOWS\\ system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\Windo wsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;D:\\Program Files\\Maven\\apache-maven-3.8.1\\bin;C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin;C:\\Program Files\\Java\\jdk1.8.0_144\\bin;D:\\Program Files\\Python38;D:\\Program Files\\nodejs;C:\\Program Files (x86)\\NetSarang\\Xshell 7;C:\\MinGW\\bin;C:\\Program Files\\Git\\cmd;C:\\User s\\windows\\AppData\\Local\\Google\\Chrome\\Application;D:\\ProgramDa ta\\Anaconda3\\Scripts;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Use rs\\windows\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.3\\bin;D:\\Program Files\\JetBrains\\WebStorm 2021.3\\bin;C:\\Users\\windows\\AppData\\Roaming\\npm;C:\\Program Files\\JetBrains\\PyCharm 2021.3\\bin;C:\\Users\\windows\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\Program Files\\JetBrains\\DataGrip 2021.3.1\\bin;. PSMODULEPATH=C:\\Users\\windows\\Documents\\WindowsPowerShell\\Modules;C:\\Progra m Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShel l\\v1.0\\Modules REQUESTS_CA_BUNDLE=\u0026lt;not set\u0026gt; SSL_CERT_FILE=\u0026lt;not set\u0026gt; active environment : tmc active env location : D:\\ProgramData\\Anaconda3\\envs\\tmc shell level : 2 user config file : C:\\Users\\windows\\.condarc populated config files : C:\\Users\\windows\\.condarc conda version : 4.10.1 conda-build version : 3.21.4 python version : 3.8.8.final.0 virtual packages : __cuda=11.4=0 __win=0=0 __archspec=1=x86_64 base environment : D:\\ProgramData\\Anaconda3 (writable) conda av data dir : D:\\ProgramData\\Anaconda3\\etc\\conda conda av metadata url : https://repo.anaconda.com/pkgs/main channel URLs : https://repo.anaconda.com/pkgs/main/win-64 https://repo.anaconda.com/pkgs/main/noarch https://repo.anaconda.com/pkgs/r/win-64 https://repo.anaconda.com/pkgs/r/noarch https://repo.anaconda.com/pkgs/msys2/win-64 https://repo.anaconda.com/pkgs/msys2/noarch package cache : D:\\ProgramData\\Anaconda3\\pkgs C:\\Users\\windows\\.conda\\pkgs C:\\Users\\windows\\AppData\\Local\\conda\\conda\\pkgs envs directories : D:\\ProgramData\\Anaconda3\\envs C:\\Users\\windows\\.conda\\envs C:\\Users\\windows\\AppData\\Local\\conda\\conda\\envs platform : win-64 user-agent : conda/4.10.1 requests/2.25.1 CPython/3.8.8 Windows/10 Windows/10.0.19041 administrator : False netrc file : None offline mode : False An unexpected error has occurred. Conda has prepared the above report. If submitted, this report will be used by core maintainers to improve future releases of conda. Would you like conda to send this report to the core maintainers? [y/N]: n No report sent. To permanently opt-out, use $ conda config --set report_errors false 解决方案 # 出现这个问题后，有比较多的解决方案：\n使用命令清理缓存，conda clean -i 删除 ~/.condarc (C:\\Users\\admin) 关闭梯子（大杀招） 反正就是让人头大，解决方案希望对大家有用\n","date":"2021年12月05日","externalUrl":null,"permalink":"/posts/condafix/","section":"Posts","summary":"","title":"conda报错：An unexpected error has occurred. Conda has prepared the above report. Upload did not complete.","type":"posts"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","section":"Tags","summary":"","title":"环境配置","type":"tags"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","section":"Categories","summary":"","title":"问题解决","type":"categories"},{"content":"","date":"2021年12月05日","externalUrl":null,"permalink":"/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","section":"Tags","summary":"","title":"问题解决","type":"tags"},{"content":"","date":"2021年12月04日","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":" Linux常用命令 # 一些感想\n测试 # ","date":"2021年12月04日","externalUrl":null,"permalink":"/posts/reading/","section":"Posts","summary":"","title":"Reading","type":"posts"},{"content":"","date":"2021年12月04日","externalUrl":null,"permalink":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/","section":"Tags","summary":"","title":"命令行","type":"tags"},{"content":"","date":"2021年11月21日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2021年11月21日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%AE%A2/","section":"Tags","summary":"","title":"博客","type":"tags"},{"content":" 第一次部署网站\u0026amp;一些想法 # 一些废话 # 虽然这个标题叫“第一次部署网站”，但其实我私下里已经部署过另外一个博客了，所以实际上是第二次。之前部署的博客是基于halo这个动态博客框架，为什么会放弃这个已经部署好的网站，而选择另外的框架呢？\n主要原因是我比较折腾，halo提供的博客系统其实非常完善了，提供了完善的前后台管理，评论系统，搜索等功能，本来我也非常喜欢的。\n但是有一个缺点我不太能接受，它需要登录到博客系统后台才能开始写文章，当然你也可以在本地创作完稿子，再把它复制粘贴到后台，然后发布。这个操作也不是不行，对于喜欢本地Markdown创作，然后push到博客上的同学来说，感觉比较别扭。\n其实，最为主要的原因是动态博客需要服务器来进行部署，服务器虽然不是太贵，以腾讯云的轻量云服务器来说，第一次购买一年74元，再搭上一个域名，小两百就没了，所以能白嫖就白嫖。\n静态博客系统相比于动态博客的优点在于网站部署可以完全不用服务器，也就是说可以省掉74块钱乃至更多，毕竟服务器续费需要花更多钱。\n正文 # 部署一个不花钱的博客，有比较多的选项，常用的Github Pages + Hugo/Hexo 等其他静态博客系统，如果觉得Github访问过慢，可以采用国内的Gitee Pages，又或者使用其他云服务商提供的CDN加速。\n个人推荐使用Hugo来构建自己的博客，倒也没啥太大的原因，就是因为我的电脑不能安装Hexo，就弃坑了（O(∩_∩)O哈哈~）。Hugo也很强大，Github 关注55.6k，而Hexo只有33.8k，用就用最热门的，出bug了也方便找。下面是部署使用的一些环境：\n操作系统采用 Ubuntu 20.04 LTS，博客系统采用Hugo，静态托管使用Github Pages。\nHugo安装和配置 # Hugo的安装比较简单，Windows平台需要进入Hugo官网下载Hugo，Ubuntu只需要在终端输入以下命令：\nsudo apt-get install hugo 不确定是否安装完成，可以验证一下：\nhugo version 确认安装完成之后，找到一个喜欢的目录\nhugo new site myfirstblog 运行以上的命令会生成一个myfirstblog文件夹，请熟记这个目录，他就是以后的大本营，可千万别给删了，这个文件夹里包含了博客系统的所有文件。\n创建完一个博客项目后，去官网选一个喜欢的主题\ncd myfirstblog git clone https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 在这里，我选择了一个比较经典的主题\u0026ndash;PaperMod，使用git clone的方式下载themes文件夹中。每一个主题都有自己特有的配置，为了让这些配置生效，需要将它们写入到配置文档中。\nHugo提供了一个文档config.toml来编写自己的主题设置，该文件位于主目录下，以PaperMod主题为例，官方会提供一个完整的配置示例，在初期我们只要将这个配置复制粘贴就可以用了，后期上手之后可以做更多定制化的内容，配置如下：\nbaseURL: \u0026#34;https://examplesite.com/\u0026#34; title: ExampleSite paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: ExampleSite description: \u0026#34;ExampleSite description\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: Me # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog socialIcons: - name: twitter url: \u0026#34;https://twitter.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 # Read: https://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma # pygmentsUseClasses: true # markup: # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai 上面的操作完成了骨干的构建，下面开始完善博客的血肉，即文章内容，创建一篇新的文章采用以下命令：\nhugo new post/first.md 当前上面的操作准备就绪后，可以使用Hugo的功能进行本地预览\nhugo server 开启服务后，在浏览器输入http://localhost:1313即可进入网站，在网站中可以看见刚下载好的主题和创建的第一篇文章。至此，Hugo的初步搭建就完成了，使用下面的命令可以完成Hugo的生产环境搭建：\nhugo -D Github Pages配置 # 完成上面的工作之后，就可以进行下面的工作，将自己的静态博客部署到Github Pages上，实现全网访问(理论上，受限于国内的网络)。\n进入Github官网，点击右上方的\u0026quot;+\u0026quot;，新建一个仓库，仓库名为\u0026quot;xxx.github.io\u0026quot;，第一个xxx必须为用户的昵称，没有商量的余地。比如我的Github用户名为\u0026quot;dancingmonkey\u0026quot;，那么仓库名就为\u0026quot;dancingmonkey.github.io\u0026quot;，这个极容易出错，不按照命名规则来，可能就要花很长时间来debug了。\n仓库创建好之后，将博客目录下的public文件夹中的所有内容上传到该仓库：\ncd public git init git commit -m \u0026#34;first commit\u0026#34; git remote add origin 仓库名 git push -u origin master 如果按照步骤来的话，每个配置都保持一致，那么这个时候你的博客就可以在全网访问了。追求更好的用户体验可以购买一个域名，在域名提供商的DNS解析处，将域名解析到对应的Github仓库名。同时，还需要在仓库的设置页面中，找到Pages设置项，在其中的Custom Domain(自定义域名)处输入自己购买的域名。\n至此，使用Hugo和Github Pages搭建一个免费的静态博客就完成了，唯一需要额外花费的就是域名了。\n一些感想 # 花了很长的时间才把网站部署起来，一方面是懒，云服务器买了，域名也买了，啥都齐了，但就是没把博客搞起来。现在回想起来，实际用来部署网站时间的，也就1个小时，剩下的时间都在找bug了。总是不相信别人的教程，每次都偏离一点路线，然后就出大错了。总结下来，一定要按步骤来，在复现结果之后在开始玩其他花样，还没有复现就开始玩花样等于找死。\n","date":"2021年11月21日","externalUrl":null,"permalink":"/posts/first/","section":"Posts","summary":"","title":"第一次部署网站\u0026一些想法","type":"posts"},{"content":"","date":"2021年11月21日","externalUrl":null,"permalink":"/tags/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","section":"Tags","summary":"","title":"静态网站","type":"tags"},{"content":"","date":"2021年11月21日","externalUrl":null,"permalink":"/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/","section":"Categories","summary":"","title":"生活随笔","type":"categories"},{"content":"","date":"2021年11月21日","externalUrl":null,"permalink":"/tags/%E9%9A%8F%E7%AC%94/","section":"Tags","summary":"","title":"随笔","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]